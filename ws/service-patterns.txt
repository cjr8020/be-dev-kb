	*****************

		patterns

	*****************

https://microservices.io/patterns/


================================================================================

	CAP Theorem
	***********
https://mwhittaker.github.io/blog/an_illustrated_proof_of_the_cap_theorem/

A distributed system can only have 2 of the 3:

Consistency
-----------

	every node can see the same data at the same time.
	I.e., performing a READ operation will return the value of the most recent
	WRITE operation causing all nodes to return the same data.

	A system has consistency if a transaction starts with the system in a 
	consistent state, and ends with the system in a consistent state.

	In this model, a system can (and does) shift into an inconsistent state
	during a transaction, but the entire transaction gets rolled back if there
	is an error during any stage of the process.

Availability
------------

	every request gets a response on success/failure.
	system remains operational 100% of the time.
	isn't feasible when analyzing streaming data at high frequency.


Partition Tolerance
-------------------

	a system that is partition-tolerant can sustain any amount of network 
	failure that doesn't result in a failure of the entire network.
	Data records are sufficiently replicated across a combination of nodes and
	networks to keep the system up thru intermittent outages.


Distributed systems:

	- achieve higher level of computing power
	- availability
	- higher performance
	- low latency
	- redundant data centers
but
	- they are more complex



================================================================================

	Transactions in distributed applications
	****************************************

Compensating transactions patterns
----------------------------------
https://dzone.com/articles/transactions-in-microservices

1. State Store
2. Routing Slip
3. Process Manager

State Store
-----------

Composite service records the state changes in a state store.
In case of failure, state store can be used to find and recover
incomplete transactions.

Routing slip
------------

Routing slip contains a list of distributed operations that needs to be executed
to complete a distributed transaction.  As services participating in the business
transaction execute those operations, they update the routing slip before 
handing message to the next service.

In case of failure, a message is sent to an error queue, where the composite 
service can look at the state and error status and compensate as required.

Process Manager
---------------

Process manager listens to events generated by services participating in the
business transaction and decides on compensating or completing the transaction.


Distributed Saga
================
https://microservices.io/patterns/data/saga.html

https://dzone.com/articles/distributed-sagas-for-microservices

first mentioned in Princeton university research paper in 1987
http://www.cs.cornell.edu/andru/cs711/2002fa/reading/sagas.pdf
conceptual alternative for long lived database transactions
2015
https://github.com/aphyr/dist-sagas/blob/master/sagas.pdf

Saga =
	high-level business process that
	consists of several low-level requests 
	each updating data within a single service
	each request has a compensating request

Distributed Saga Guarantee

	a distributed saga guarantees one of the following two outcomes:

	1. Either all Requests in the Saga are succesfully completed, or
	2. A subset of Requests and their Compensating Requests are executed.	

Sagas as state machines


Sage with Camunda and spring-boot
---------------------------------

https://blog.bernd-ruecker.com/saga-how-to-implement-complex-business-transactions-without-two-phase-commit-e00aa41a1b1b
src: 
https://github.com/berndruecker/flowing-trip-booking-saga


================================================================================

	Command Pattern
	***************

Receiver
--------

public class Light {
  public  void turnOn() {
    System.out.println("Light is on");
  }

  public void turnOff() {
    System.out.println("Light is off");
  }
}

Command
--------

public class TurnOnLightCommand implements Runnable {

  Light light;

  public TurnOnLightCommand(Light light) {
    super();
    this.light = light;
  }

  @Override
  public void run() {
    System.out.println("Turning on light.");
    light.turnOn();
  }
}

Invoker
-----------

public class HomeAutomationRemote {

  // command holder
  Runnable command;

  public void setCommand(Runnable command) {
    this.command = command;
  }

  public void buttonPressed() {
    command.run();
  }
}

Light livingRoomLight = new Light();    //receiver 1
HomeAutomationRemote remote = new HomeAutomationRemote();   //Invoker

remote.setCommand(new TurnOnLightCommand( livingRoomLight ));
remote.buttonPressed();

================================================================================

	Saga experimentation
	********************

Process step
---------------

public class ProcessStep {

  private Runnable action;
  private Runnable compensatingAction;

  ProcessStep(Runnable action, Runnable compensatingAction) {
    this.action = action;
    this.compensatingAction = compensatingAction;
  }

  public Runnable getAction() {
    return action;
  }

  public void setAction(Runnable action) {
    this.action = action;
  }

  public Runnable getCompensatingAction() {
    return compensatingAction;
  }

  public void setCompensatingAction(Runnable compensatingAction) {
    this.compensatingAction = compensatingAction;
  }

  @Override
  public String toString() {
    return new StringJoiner(", ", "ProcessStep{", "}")
        .add("action=" + action)
        .add("compensatingAction=" + compensatingAction)
        .toString();
  }
}

Saga
-------

public class Saga {

  private LinkedHashSet<ProcessStep> processSteps = new LinkedHashSet<>();
  private String processName;

  public Saga(final String processName) {
    this.processName = processName;
  }

  public Saga add(ProcessStep processStep) {
    processSteps.add(processStep);
    return this;
  }

  public LinkedHashSet<ProcessStep> getProcessSteps() {
    return this.processSteps;
  }

  @Override
  public String toString() {
    return new StringJoiner(", ", "Saga{", "}")
        .add("processSteps=" + processSteps)
        .toString();
  }
}

SagaExecutor
------------------

public class SagaExecutor {

  private Saga saga;
  private Deque<ProcessStep> sagaLog = new LinkedList<>();

  public SagaExecutor (final Saga saga) {
    this.saga = saga;
  }

  public SagaExecutor execute() {

    try {

      for (ProcessStep processStep : this.saga.getProcessSteps()) {
        this.sagaLog.push(processStep);
        Runnable action = processStep.getAction();
        action.run();
      }

    } catch (RuntimeException exception) {
      System.err.println("ERROR: " + exception.getMessage());
      rollback();
    }

    return this;
  }

  private void rollback() {
    sagaLog.descendingIterator().forEachRemaining(processStep -> processStep.getCompensatingAction().run());
  }

}


Test
--------------

  @Test
  public void testSaga_withFailure() {

    ProcessStep processStepOne = new ProcessStep(
        () -> System.out.println("Action 1"),
        () -> System.out.println("Undo Action 1")
    );

    ProcessStep processStepTwo = new ProcessStep(
        () -> System.out.println("Action 2"),
        () -> System.out.println("Undo Action 2")
    );

    ProcessStep processStepThree = new ProcessStep(
        () -> {
          System.out.println("Action 3");
          throw new RuntimeException("Action 3 Error");
        },
        () -> System.out.println("Undo Action 3")
    );

    ProcessStep processStepFour = new ProcessStep(
        () -> System.out.println("Action 4"),
        () -> System.out.println("Undo Action 4")
    );

    Saga saga = new Saga("test-process")
        .add(processStepOne)
        .add(processStepTwo)
        .add(processStepThree)
        .add(processStepFour);

    SagaExecutor executor = new SagaExecutor(saga)
        .execute();
  }





================================================================================