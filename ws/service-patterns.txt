	*****************

		patterns

	*****************


================================================================================

	CAP Theorem
	***********
https://mwhittaker.github.io/blog/an_illustrated_proof_of_the_cap_theorem/

A distributed system can only have 2 of the 3:

Consistency
-----------

	every node can see the same data at the same time.
	I.e., performing a READ operation will return the value of the most recent
	WRITE operation causing all nodes to return the same data.

	A system has consistency if a transaction starts with the system in a 
	consistent state, and ends with the system in a consistent state.

	In this model, a system can (and does) shift into an inconsistent state
	during a transaction, but the entire transaction gets rolled back if there
	is an error during any stage of the process.

Availability
------------

	every request gets a response on success/failure.
	system remains operational 100% of the time.
	isn't feasible when analyzing streaming data at high frequency.


Partition Tolerance
-------------------

	a system that is partition-tolerant can sustain any amount of network 
	failure that doesn't result in a failure of the entire network.
	Data records are sufficiently replicated across a combination of nodes and
	networks to keep the system up thru intermittent outages.


Distributed systems:

	- achieve higher level of computing power
	- availability
	- higher performance
	- low latency
	- redundant data centers
but
	- they are more complex



================================================================================

	Transactions in distributed applications
	****************************************

Compensating transactions patterns
----------------------------------
https://dzone.com/articles/transactions-in-microservices

1. State Store
2. Routing Slip
3. Process Manager

State Store
-----------

Composite service records the state changes in a state store.
In case of failure, state store can be used to find and recover
incomplete transactions.

Routing slip
------------

Routing slip contains a list of distributed operations that needs to be executed
to complete a distributed transaction.  As services participating in the business
transaction execute those operations, they update the routing slip before 
handing message to the next service.

In case of failure, a message is sent to an error queue, where the composite 
service can look at the state and error status and compensate as required.

Process Manager
---------------

Process manager listens to events generated by services participating in the
business transaction and decides on compensating or completing the transaction.


Distributed Saga
================
https://microservices.io/patterns/data/saga.html

https://dzone.com/articles/distributed-sagas-for-microservices

first mentioned in Cornell university research paper in 1987
http://www.cs.cornell.edu/andru/cs711/2002fa/reading/sagas.pdf
conceptual alternative for long lived database transactions
2015
https://github.com/aphyr/dist-sagas/blob/master/sagas.pdf

Saga =
	high-level business process that
	consists of several low-level requests 
	each updating data within a single service
	each request has a compensating request

Distributed Saga Guarantee

	a distributed saga guarantees one of the following two outcomes:

	1. Either all Requests in the Saga are succesfully completed, or
	2. A subset of Requests and their Compensating Requests are executed.	

Sagas as state machines

AWS Step Functions
--------------------
https://aws.amazon.com/step-functions/

 can be used as an Saga Execution Coordinator to oversee the execution of our distributed sagas.



================================================================================