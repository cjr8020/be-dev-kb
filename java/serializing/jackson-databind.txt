
	**************************

		FasterXML Jackson

	**************************


================================================================================			

  spring boot input validation
  ****************************

Hibernate Validator
=======================

Included with spring-boot-starter-web.


    DecimalMax
    DecimalMin
    Digits
    Email
    Future
    FutureOrPresent
    Max
    Min
    Negative
    NegativeOrZero
    NotBlank
    NotEmpty
    NotNull
    Null
    Past
    PastOrPresent
    Pattern
    Positive
    PositiveOrZero

To enable validate on a resource

    public ResponseEntity<Object> createStudent(@Valid @RequestBody Student student) {
    }

  and annotate your REST resource class fields with appropriate validators.


Examples of validation
----------------------

  @JsonProperty
  @NotNull
  @Pattern(regexp = "^[\\d]+$")
  private String digitsOnly;

  @JsonProperty
  @NotNull
  @Pattern(regexp = "^[\\d]{6}$")
  private String sixDigits;

  @JsonProperty
  @NotNull
  @Digits(integer = 6, fraction = 0) <-- Did not work for me, @Pattern instead.
  private String blah;  

  @JsonProperty
  @NotNull
  @Pattern(regexp = "[^\\d{4}-\\d{2}-\\d{2}$]")
  private Date birthDate;  // 2000-12-31

  // dollar amount
  @Pattern(regexp = "^[0-9]+(\\.[0-9]+)?$")  - does not work with BigDecimal

  // decimal amount - BigDecimal

  @JsonProperty
  @NotNull
  @Digits(integer=15, fraction=2)
  private BigDecimal lastPayment;

  // dates

  // this pattern is valid but does not work with LocalDate
  @Pattern(regexp = "^(0[1-9]|1[012])[- \\/.](0[1-9]|[12][0-9]|3[01])[- \\/.](19|20)\\d\\d$")

  @Past / @PastOrPresent
  @Future / @FutureOrPresent

  @JsonProperty
  @NotNull
  @PastOrPresent
  private LocalDate periodEndDate;

  
 Value is a two-letter code 

  /* AB|CD|EF|GH| etc  */
  @JsonProperty
  @NotNull
  @Pattern(regexp = "^[a-zA-Z]{2}$", flags = Flag.CASE_INSENSITIVE)
  private String claimCategory;

email

  @JsonProperty
  @NotNull
  @Pattern(regexp = "^([\\w.\\-]+)@([\\w\\-]+)((\\.(\\w){2,})+)$")
  private String email;


 one of two values

   @JsonProperty
   @NotNull
   @Pattern(regexp = "^(yes|no)$", flags = Flag.CASE_INSENSITIVE)
   private String yesOrNo;


Custom Validators
==================
https://g00glen00b.be/validating-the-input-of-your-rest-api-with-spring/

While there are many built-in validations already, sometimes, there isn’t an annotation that’s doing exactly what you want. But no worries, what isn’t there can be made! For example, let’s say that our users have to be at least 18 years old (no, it’s not what you’re thinking), so let’s create our own, @Adult annotation:

@Documented
@Retention(RUNTIME)
@Target({FIELD, ANNOTATION_TYPE, PARAMETER})
@Constraint(validatedBy = AdultValidator.class)
public @interface Adult {
    String message() default "{adult}";
    Class<?>[] groups() default { };
    Class<? extends Payload>[] payload() default { };
}


Now, to make this annotation work, we also have to write our business logic in a class called AdultValidator, which we pass to the @Constraint annotation as you can see above.


@Component
public class AdultValidator implements ConstraintValidator<Adult, LocalDate> {
    private static final int ADULT_AGE = 18;

    @Override
    public boolean isValid(LocalDate dateOfBirth, ConstraintValidatorContext constraintValidatorContext) {
        return dateOfBirth != null && LocalDate.now().minusYears(ADULT_AGE).isAfter(dateOfBirth);
    }
}



================================================================================			

	Flatten nested JSON objects
	***************************

Target:

public class Product {
 
    private String id;
    private String name;
    private String brandName;
    private String ownerName;
 
    // standard getters and setters
}


source:

{
    "id": "957c43f2-fa2e-42f9-bf75-6e3d5bb6960a",
    "name": "The Best Product",
    "brand": {
        "id": "9bcd817d-0141-42e6-8f04-e5aaab0980b6",
        "name": "ACME Products",
        "owner": {
            "id": "b21a80b1-0c09-4be3-9ebd-ea3653511c13",
            "name": "Ultimate Corp, Inc."
        }
    }  
}

using annotation
---------------------

To map nested brand/name into `brandName`, we need to 
first unpack the nested object to a Map, and extract the "name" property:

instruct Jackson to unpack the nested property using a combination of @JsonProperty
and some custom logic:


public class Product {
    // ...
 
    @SuppressWarnings("unchecked")
    @JsonProperty("brand")
    private void unpackNested(Map<String,Object> brand) {
        this.brandName = (String)brand.get("name");
        Map<String,String> owner = (Map<String,String>)brand.get("owner");
        this.ownerName = owner.get("name");
    }
}

using custom JsonDeserializer
------------------------------

ProductDeserializer.class
=========================
public class ProductDeserializer extends StdDeserializer<Product> {
 
    public ProductDeserializer() {
        this(null);
    }
 
    public ProductDeserializer(Class<?> vc) {
        super(vc);
    }
 
    @Override
    public Product deserialize(JsonParser jp, DeserializationContext ctxt) 
      throws IOException, JsonProcessingException {
  
        JsonNode productNode = jp.getCodec().readTree(jp);
        Product product = new Product();
        product.setId(productNode.get("id").textValue());
        product.setName(productNode.get("name").textValue());
        product.setBrandName(productNode.get("brand")
          .get("name").textValue());
        product.setOwnerName(productNode.get("brand").get("owner")
          .get("name").textValue());        
        return product;
    }
}

Register the Deserializer on the Product.class

@JsonDeserialize(using = ProductDeserializer.class)
public class Product {
    // ...
}


================================================================================			

	Ignore empty (null) values
	**************************

Configure ObjectMapper:

	mapper.setSerializationInclusion(Include.NON_NULL);

============================================================================	

	UnrecognizedPropertyException
	*****************************

	@JsonIgnore

	@JsonIgnoreProperties(ignoreUnknown = true)

		this will of course help, but you wouldn't know exactly what
		you're ignoriing.. 

You could be getting an exception like this 

javax.ws.rs.ProcessingException: Error reading entity from input stream.
        at com.fasterxml.jackson.databind.exc.UnrecognizedPropertyException.from(UnrecognizedPropertyException.java:51)

without any hint as to what might be causing it.

In your DTO classes, it isn't only fields you need to worry about.

It is also methods like:

	isEligible
	isSomethingSometing

that might be causing this during marshalling and unmarshaling.        

What seems to work is to add @JsonIgnore above such methods:

  @JsonIgnore
  public boolean isLegacyAppBridge() {
    return id.equals(LEGACY_APP_BRIDGE_ID);
  }

  @JsonIgnore
  public boolean isExternallyConfigured() {
    return this.type.equals(APP_CONFIG_EXTERNAL);
  }

  @JsonIgnore
  public boolean isStaticallyConfigured() {
    return this.type.equals(APP_CONFIG_STATIC);
  }


================================================================================			

	Custom Deserializer
	*******************

SomeOuterObject.class

public class OuterObject {
	
	@JsonProperty
	private Long id;

	@JsonProperty
	private InnerObject innerObject;

}


@JsonDeserialize(using = InnerObjectDeserializer.class)
public class InnerObject {

  @JsonProperty
  private String firstName;

  @JsonProperty
  private String lastName;
}

InnerObjectDeserializer.class
------------------------------

public class InnerObjecttDeserializer extends StdDeserializer<InnerObject> {

  public InnerObjectDeserializer() {
    super(InnerObject.class);
  }

  protected InnerObjectDeserializer(Class<?> vc) {
    super(vc);
  }

  protected InnerObjectDeserializer(JavaType valueType) {
    super(valueType);
  }

  protected InnerObjectDeserializer(StdDeserializer<?> src) {
    super(src);
  }

  @Override
  public InnerObject deserialize(JsonParser jsonParser,
      DeserializationContext deserializationContext) throws IOException, JsonProcessingException {

    ObjectCodec oc = jsonParser.getCodec();
    JsonNode node = oc.readTree(jsonParser);

    InnerObject innerObject = new InnerObject();
    innerObject.setFirstName(node.get("firstName").asText());
    innerObject.setLastName(node.get("lastName").asText());

    return aboutClaimant;
  }
}

================================================================================			