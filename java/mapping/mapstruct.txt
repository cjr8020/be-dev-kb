
	******************

		Mapstruct

	******************		

http://mapstruct.org/documentation/stable/reference/html/

================================================================================	

	Basic Mapper
	************

* When a property has the same name as its target entity counterpart, it will be mapped implicitly.
* When a property has a different name in the target entity, 
  its name can be specified via the @Mapping annotation.



To create a mapper simply define a Java interface with the required mapping method(s) and annotate it with the org.mapstruct.Mapper annotation:

@Mapper
public interface CarMapper {

    @Mapping(source = "make", target = "manufacturer")
    @Mapping(source = "numberOfSeats", target = "seatCount")
    CarDto carToCarDto(Car car);

    @Mapping(source = "name", target = "fullName")
    PersonDto personToPersonDto(Person person);
}



	@BeanMapping(ignoreByDefault = true)
	------------------------------------

	
By means of the @BeanMapping(ignoreByDefault = true) the default behavior will be explicit mapping, meaning that all mappings have to be specified by means of the @Mapping and no warnings will be issued on missing target properties.	

================================================================================	

	Custom method in Mapper
	***********************

In some cases it can be required to manually implement a specific mapping from one type to another which can’t be generated by MapStruct. One way to handle this is to implement the custom method on another class which then is used by mappers generated by MapStruct.


when using Java 8 or later, you can implement custom methods directly in a mapper interface as default methods. The generated code will invoke the default methods if the argument and return types match.

@Mapper
public interface CarMapper {

    @Mapping(...)
    ...
    CarDto carToCarDto(Car car);

    default PersonDto personToPersonDto(Person person) {
        //hand-written mapping logic
    }
}


Abstract class
--------------

A mapper could also be defined in the form of an abstract class instead of an interface and implement the custom methods directly in the mapper class. In this case MapStruct will generate an extension of the abstract class with implementations of all abstract methods. 

An advantage of this approach over declaring default methods is that additional fields could be declared in the mapper class.



================================================================================	

	Methods with several source parameters
	**************************************

MapStruct also supports mapping methods with several source parameters. 
This is useful e.g. in order to combine several entities into one data transfer object.


@Mapper
public interface AddressMapper {

    @Mapping(source = "person.description", target = "description")
    @Mapping(source = "address.houseNo", target = "houseNumber")
    DeliveryAddressDto personAndAddressToDeliveryAddressDto(Person person, Address address);
}


================================================================================	

	Updating Existing Bean instance
	*******************************

@MappingTarget

	adding a parameter for the target object and marking this parameter with @MappingTarget

@Mapper
public interface CarMapper {

    void updateCarFromDto(CarDto carDto, @MappingTarget Car car);
}

The generated code of the updateCarFromDto() method will update the passed Car instance with the properties from the given CarDto object. 

There may be only one parameter marked as mapping target.


================================================================================	

	Mappings with direct field access
	*********************************

MapStruct also supports mappings of public fields that have no getters/setters. 

MapStruct will use the fields as read/write accessor if it cannot find suitable getter/setter methods for the property.


================================================================================	

	Builders
	********

MapStruct also supports mapping of immutable types via builders. 	


================================================================================	
================================================================================	


	Retrieving Mappers
	******************

Mapper instances can be retrieved via the org.mapstruct.factory.Mappers class. Just invoke the getMapper() method, passing the interface type of the mapper to return:


	CarMapper mapper = Mappers.getMapper( CarMapper.class );


By convention, a mapper interface should define a member called INSTANCE which holds a single instance of the mapper type:

@Mapper
public interface CarMapper {

    CarMapper INSTANCE = Mappers.getMapper( CarMapper.class );

}

This pattern makes it very easy for clients to use mapper objects without repeatedly instantiating new instances:


	Car car = ...;
	CarDto dto = CarMapper.INSTANCE.carToCarDto( car );

--------------------------------------------------------------------------------

	Retrieving using DI dependency injection
	****************************************

If you’re working with a dependency injection framework, it is recommended to obtain mapper objects via dependency injection as well. 

To use Spring IoC in our mapper, we need to add the componentModelattribute to @Mapper with the value "spring" and for CDI would be "cdi":

@Mapper(componentModel = "spring")
public interface CarMapper {

    CarDto carToCarDto(Car car);
}


@Inject
private CarMapper mapper;


Injection Strategy
----------------------

When using dependency injection, you can choose between field and constructor injection. 
This can be done by either providing the injection strategy via 
@Mapper or 
@MapperConfig annotations:


@Mapper(
	componentModel = "cdi", 
	uses = EngineMapper.class, 
	injectionStrategy = InjectionStrategy.CONSTRUCTOR
)
public interface CarMapper {
    CarDto carToCarDto(Car car);
}

The generated mapper will inject all classes defined in the `uses` attribute. 

When InjectionStrategy#CONSTRUCTOR is used, the constructor will have the appropriate annotation and the fields won’t. 

When InjectionStrategy#FIELD is used, the annotation is on the field itself. 
For now, the default injection strategy is field injection. 

It is recommended to use constructor injection to simplify testing.

================================================================================	
================================================================================	

	Data Type Conversions
	*********************





================================================================================	
================================================================================	

	Installation
	************
http://mapstruct.org/documentation/installation/

Maven
----------------------------------------

...
<properties>
    <org.mapstruct.version>1.3.0.Final</org.mapstruct.version>
</properties>
...
<dependencies>
    <dependency>
        <groupId>org.mapstruct</groupId>
        <artifactId>mapstruct</artifactId>
        <version>${org.mapstruct.version}</version>
    </dependency>
</dependencies>
...
<build>
    <plugins>
        <plugin>
            <groupId>org.apache.maven.plugins</groupId>
            <artifactId>maven-compiler-plugin</artifactId>
            <version>3.5.1</version> <!-- or newer version -->
            <configuration>
                <source>1.8</source> <!-- depending on your project -->
                <target>1.8</target> <!-- depending on your project -->
                <annotationProcessorPaths>
                    <path>
                        <groupId>org.mapstruct</groupId>
                        <artifactId>mapstruct-processor</artifactId>
                        <version>${org.mapstruct.version}</version>
                    </path>
                    <!-- other annotation processors -->
                </annotationProcessorPaths>
            </configuration>
        </plugin>
    </plugins>
</build>



================================================================================	