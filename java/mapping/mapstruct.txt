
	******************

		Mapstruct

	******************		

http://mapstruct.org/documentation/stable/reference/html/
https://github.com/mapstruct/mapstruct-examples

================================================================================	

	Basic Mapper
	************

* When a property has the same name as its target entity counterpart, it will be mapped implicitly.
* When a property has a different name in the target entity, 
  its name can be specified via the @Mapping annotation.



To create a mapper simply define a Java interface with the required mapping method(s) and annotate it with the org.mapstruct.Mapper annotation:

@Mapper
public interface CarMapper {

    @Mapping(source = "make", target = "manufacturer")
    @Mapping(source = "numberOfSeats", target = "seatCount")
    CarDto carToCarDto(Car car);

    @Mapping(source = "name", target = "fullName")
    PersonDto personToPersonDto(Person person);
}



	@BeanMapping(ignoreByDefault = true)
	------------------------------------

	
By means of the @BeanMapping(ignoreByDefault = true) the default behavior will be explicit mapping, meaning that all mappings have to be specified by means of the @Mapping and no warnings will be issued on missing target properties.	

================================================================================	

	Custom method in Mapper
	***********************

In some cases it can be required to manually implement a specific mapping from one type to another which can’t be generated by MapStruct. One way to handle this is to implement the custom method on another class which then is used by mappers generated by MapStruct.


when using Java 8 or later, you can implement custom methods directly in a mapper interface as default methods. The generated code will invoke the default methods if the argument and return types match.

@Mapper
public interface CarMapper {

    @Mapping(...)
    ...
    CarDto carToCarDto(Car car);

    default PersonDto personToPersonDto(Person person) {
        //hand-written mapping logic
    }
}


Abstract class
--------------

A mapper could also be defined in the form of an abstract class instead of an interface and implement the custom methods directly in the mapper class. In this case MapStruct will generate an extension of the abstract class with implementations of all abstract methods. 

An advantage of this approach over declaring default methods is that additional fields could be declared in the mapper class.



================================================================================	

	Methods with several source parameters
	**************************************

MapStruct also supports mapping methods with several source parameters. 
This is useful e.g. in order to combine several entities into one data transfer object.


@Mapper
public interface AddressMapper {

    @Mapping(source = "person.description", target = "description")
    @Mapping(source = "address.houseNo", target = "houseNumber")
    DeliveryAddressDto personAndAddressToDeliveryAddressDto(Person person, Address address);
}


================================================================================	

	Map Object References
	*********************

Typically an object has not only primitive attributes but also references other objects. 
E.g. the Car class could contain a reference to a Person object (representing the car’s driver) which should be mapped to a PersonDto object referenced by the CarDto class.

In this case just define a mapping method for the referenced object type as well:

@Mapper
public interface CarMapper {

    CarDto carToCarDto(Car car);

    PersonDto personToPersonDto(Person person);
}

The generated code for the carToCarDto() method will invoke the personToPersonDto() method for mapping the driver attribute, while the generated implementation for personToPersonDto() performs the mapping of person objects.
That way it is possible to map arbitrary deep object graphs. 

Cutting references
-------------------

When mapping from entities into data transfer objects it is often useful to cut references to other entities at a certain point.  E.g. map a referenced entity to its id, rather than an object.

Controlling nested bean mappings
--------------------------------





================================================================================	

	Updating Existing Bean instance
	*******************************

@MappingTarget

	adding a parameter for the target object and marking this parameter with @MappingTarget

@Mapper
public interface CarMapper {

    void updateCarFromDto(CarDto carDto, @MappingTarget Car car);
}

The generated code of the updateCarFromDto() method will update the passed Car instance with the properties from the given CarDto object. 

There may be only one parameter marked as mapping target.


================================================================================	

	Mappings with direct field access
	*********************************

MapStruct also supports mappings of public fields that have no getters/setters. 

MapStruct will use the fields as read/write accessor if it cannot find suitable getter/setter methods for the property.


================================================================================	

	Builders
	********

MapStruct also supports mapping of immutable types via builders. 	


================================================================================	
================================================================================	


	Retrieving Mappers
	******************

Mapper instances can be retrieved via the org.mapstruct.factory.Mappers class. Just invoke the getMapper() method, passing the interface type of the mapper to return:


	CarMapper mapper = Mappers.getMapper( CarMapper.class );


By convention, a mapper interface should define a member called INSTANCE which holds a single instance of the mapper type:

@Mapper
public interface CarMapper {

    CarMapper INSTANCE = Mappers.getMapper( CarMapper.class );

}

This pattern makes it very easy for clients to use mapper objects without repeatedly instantiating new instances:


	Car car = ...;
	CarDto dto = CarMapper.INSTANCE.carToCarDto( car );

--------------------------------------------------------------------------------

	Retrieving using DI dependency injection
	****************************************

If you’re working with a dependency injection framework, it is recommended to obtain mapper objects via dependency injection as well. 

To use Spring IoC in our mapper, we need to add the componentModelattribute to @Mapper with the value "spring" and for CDI would be "cdi":

@Mapper(componentModel = "spring")
public interface CarMapper {

    CarDto carToCarDto(Car car);
}


@Inject
private CarMapper mapper;


Injection Strategy
----------------------

When using dependency injection, you can choose between field and constructor injection. 
This can be done by either providing the injection strategy via 
@Mapper or 
@MapperConfig annotations:


@Mapper(
	componentModel = "cdi", 
	uses = EngineMapper.class, 
	injectionStrategy = InjectionStrategy.CONSTRUCTOR
)
public interface CarMapper {
    CarDto carToCarDto(Car car);
}

The generated mapper will inject all classes defined in the `uses` attribute. 

When InjectionStrategy#CONSTRUCTOR is used, the constructor will have the appropriate annotation and the fields won’t. 

When InjectionStrategy#FIELD is used, the annotation is on the field itself. 
For now, the default injection strategy is field injection. 

It is recommended to use constructor injection to simplify testing.

================================================================================	
================================================================================	

	Data Type Conversions
	*********************

Invoking other mappers
----------------------

In addition to methods defined on the same mapper type MapStruct can also invoke mapping methods defined in other classes, be it mappers generated by MapStruct or hand-written mapping methods. 

e.g.:

public class DateMapper {

    public String asString(Date date) {
        return date != null ? new SimpleDateFormat( "yyyy-MM-dd" )
            .format( date ) : null;
    }

    public Date asDate(String date) {
        try {
            return date != null ? new SimpleDateFormat( "yyyy-MM-dd" )
                .parse( date ) : null;
        }
        catch ( ParseException e ) {
            throw new RuntimeException( e );
        }
    }
}


CarMapper can now use DateMapper
---------------------------------

@Mapper(uses=DateMapper.class)
public class CarMapper {

    CarDto carToCarDto(Car car);
}

When generating code for the implementation of the carToCarDto() method, MapStruct will look for a method which maps a Date object into a String, find it on the DateMapper class and generate an invocation of asString() for mapping the manufacturingDate attribute.

================================================================================	
================================================================================	

	Mapping Collections
	*******************

The mapping of collection types (List, Set etc.) is done in the same way as mapping bean types, i.e. by defining mapping methods with the required source and target types in a mapper interface. 

The generated code will contain a loop which iterates over the source collection, converts each element and puts it into the target collection. If a mapping method for the collection element types is found in the given mapper or the mapper it uses, this method is invoked to perform the element conversion. 


@Mapper
public interface CarMapper {

    Set<String> integerSetToStringSet(Set<Integer> integers);

    List<CarDto> carsToCarDtos(List<Car> cars);

    CarDto carToCarDto(Car car);
}



================================================================================	

	Mapping Maps
	************

Also map-based mapping methods are supported. The following shows an example:

public interface SourceTargetMapper {

    @MapMapping(valueDateFormat = "dd.MM.yyyy")
    Map<String, String> longDateMapToStringStringMap(Map<Long, Date> source);
}



================================================================================	

	Mapping Streams
	***************

The mapping of java.util.Stream is done in a similar way as the mapping of collection types, i.e. by defining mapping methods with the required source and target types in a mapper interface.


================================================================================	
================================================================================	

	Installation
	************
http://mapstruct.org/documentation/installation/

Maven
----------------------------------------

...
<properties>
    <org.mapstruct.version>1.3.0.Final</org.mapstruct.version>
</properties>
...
<dependencies>
    <dependency>
        <groupId>org.mapstruct</groupId>
        <artifactId>mapstruct</artifactId>
        <version>${org.mapstruct.version}</version>
    </dependency>
</dependencies>
...
<build>
    <plugins>
        <plugin>
            <groupId>org.apache.maven.plugins</groupId>
            <artifactId>maven-compiler-plugin</artifactId>
            <version>3.5.1</version> <!-- or newer version -->
            <configuration>
                <source>1.8</source> <!-- depending on your project -->
                <target>1.8</target> <!-- depending on your project -->
                <annotationProcessorPaths>
                    <path>
                        <groupId>org.mapstruct</groupId>
                        <artifactId>mapstruct-processor</artifactId>
                        <version>${org.mapstruct.version}</version>
                    </path>
                    <!-- other annotation processors -->
                </annotationProcessorPaths>
            </configuration>
        </plugin>
    </plugins>
</build>



================================================================================	