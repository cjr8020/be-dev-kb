	@@@@@@@@@@@@@@@@@@@
	
		Spring JMS

	@@@@@@@@@@@@@@@@@@@


================================================================================

	IBM MQ 
	******


IBM MQ JMS message types and conversion
----------------------------------------

https://www.ibm.com/support/knowledgecenter/en/SSFKSJ_7.5.0/com.ibm.mq.dev.doc/q032110_.htm

JMSObjectMessage
JMSTextMessage
JMSMapMessage and JMSStreamMessage
JMSBytesMessage

MQ Java libraries
-----------------
Within an enterprise, the following files can be moved to systems that need to run IBM MQ classes for Java applications:

	com.ibm.mq.allclient.jar
	com.ibm.mq.traceControl.jar

The file com.ibm.mq.allclient.jar contains the IBM MQ classes for JMS, the IBM MQ classes for Java, and the PCF and Headers Classes. If you move this file to a new location, make sure that you take steps to keep this new location maintained with new IBM MQ Fix Packs. Also, make sure that the use of this file is made known to IBM Support if you are getting an interim fix.

MQQueueConnectionFactory
-------------------------

@Bean
public ConnectionFactory ibmConnectionFactory() throws JMSException {
    MQQueueConnectionFactory connectionFactory = new MQQueueConnectionFactory();
    connectionFactory.setHostName("myhost.example.org");
    connectionFactory.setPort(1414);
    connectionFactory.setQueueManager("MQ_NAME");
    connectionFactory.setTransportType(WMQConstants.WMQ_CM_CLIENT);
    connectionFactory.setChannel("SYSTEM.DEF.SVRCONN");
    return connectionFactory;
}

--------------------------------------------------------------------------------

@Configuration
@ConfigurationProperties("some-mq-service")
public class SomeMqServiceConfiguration extends AbstractMqServiceConfiguration {
  private static final Logger logger
      = LoggerFactory.getLogger(SomeMqServiceConfiguration.class);


  /**
   * Connection factory for SomeMqService.
   * Note: conditional on property allows one to skip this bean creation for unit tests.
   * @return CachingConnectionFactory
   */
  @Bean(name = "someMqServiceJmsConnectionFactory")
  @ConditionalOnProperty(
      prefix = "group-policy-service",
      name = "enabled",
      matchIfMissing = true)
  CachingConnectionFactory SomeMqServiceJmsConnectionFactory() {
    MQConnectionFactory wrappedConnectionFactory = createConnectionFactory();
    CachingConnectionFactory connectionFactory
        = new CachingConnectionFactory(wrappedConnectionFactory);
    connectionFactory.setCacheConsumers(true);
    connectionFactory.setSessionCacheSize(10);
    return connectionFactory;
  }


  @Bean(name = "someMqServiceJmsTemplate")
  @DependsOn("someMqServiceJmsConnectionFactory")
  public JmsTemplate someMqServiceJmsTemplate() {
    JmsTemplate jmsTemplate = new JmsTemplate();

    jmsTemplate.setConnectionFactory(SomeMqServiceJmsConnectionFactory());
    jmsTemplate.setExplicitQosEnabled(true);
    jmsTemplate.setDeliveryPersistent(false);

    return jmsTemplate;
  }




  protected MQConnectionFactory createConnectionFactory() {
    try {
      MQConnectionFactory cf = new MQConnectionFactory();
      cf.setStringProperty(WMQConstants.WMQ_QUEUE_MANAGER, getQueueManager());

      cf.setStringProperty(WMQConstants.WMQ_CONNECTION_NAME_LIST, getConnName());
      cf.setStringProperty(WMQConstants.WMQ_CHANNEL, getChannel());
      cf.setIntProperty(WMQConstants.WMQ_CONNECTION_MODE, WMQConstants.WMQ_CM_CLIENT);

      cf.setStringProperty(WMQConstants.USERID, getUser());
      cf.setStringProperty(WMQConstants.PASSWORD, getPassword());
      cf.setBooleanProperty(WMQConstants.USER_AUTHENTICATION_MQCSP, false);

      return cf;
    } catch (JMSException j) {
      throw JmsUtils.convertJmsAccessException(j);
    }
  }


================================================================================


example using MQ8
-----------------
https://stackoverflow.com/questions/42356712/java-spring-jms-jmstemplate-to-ibm-mq


@Bean
public ConnectionFactory connectionFactory() {
            properties.getCipherSpec());
    MQConnectionFactory factory = new MQConnectionFactory();
    try {
        factory.setHostName(properties.getHost());
        factory.setPort(properties.getPort());
        factory.setQueueManager(properties.getQueueManager());
        factory.setChannel(properties.getChannel());
        factory.setTransportType(WMQConstants.WMQ_CM_CLIENT);
        factory.setClientReconnectTimeout(CLIENT_RECONNECT_TIMEOUT);
        factory.setClientReconnectOptions(WMQConstants.WMQ_CLIENT_RECONNECT);
        if (properties.isEnableSsl()) {
            factory.setSSLCipherSuite(properties.getCipherSpec());
            factory.setSSLSocketFactory(socketFactory());
        }   
        factory.setUseConnectionPooling(true);  
    } catch (Exception e) {
        throw new RuntimeException(e);
    }
    return factory;
}


@Bean(name = "cachingConnectionFactory")
public CachingConnectionFactory cachingConnectionFactory(){
    CachingConnectionFactory factory = new CachingConnectionFactory();
    factory.setSessionCacheSize(50);
    factory.setTargetConnectionFactory(connectionFactory());
    factory.setReconnectOnException(true);
    factory.afterPropertiesSet();
    return factory;
}




================================================================================

  JmsTemplate send
  ****************

      jmsTemplate.send(requestQueue, session -> {

        // msgId
        String msgId = UUID.randomUUID().toString();

        TextMessage message = session.createTextMessage("blah");
        message.setJMSCorrelationID(msgId);  // .. or not .. 

        // replyToQueue
        Destination replyToDestination
            = session.createQueue(responseQueue);
        message.setJMSReplyTo(replyToDestination);

        return message;
      });



================================================================================

  JmsTemplate receiveSelected
  ***************************

Message receiveSelected(Destination destination, String messageSelector)
  Receive a message synchronously from the specified destination, 
  but only wait up to a specified time for delivery.

Message receiveSelected(String messageSelector)
  Receive a message synchronously from the default destination, 
  but only wait up to a specified time for delivery.

Message receiveSelected(String destinationName, String messageSelector)
  Receive a message synchronously from the specified destination, 
  but only wait up to a specified time for delivery.  


================================================================================

	JmsTemplate sendAndReceieve
	****************************

https://stackoverflow.com/questions/53506177/how-to-use-jmstemplate-sendandreceive

@SpringBootApplication
public class So53506177Application {

    @Autowired
    private JmsTemplate jmsTemplate;


    @Bean
    public ApplicationRunner runner(JmsTemplate jmsTemplate) {
        return args -> {
            jmsTemplate.setReceiveTimeout(20000);
            Message received = jmsTemplate.sendAndReceive("foo", new MessageCreator() {

                @Override
                public Message createMessage(Session session) throws JMSException {
                    String msgId = "foo";
                    TextMessage message = session.createTextMessage("foo");
                    message.setJMSCorrelationID(msgId);
                    return message;
                }
            });
            System.out.println("Reply: " + this.converter.fromMessage(received));
        };
    }

}


================================================================================

	JmsTemplate
	***********

https://docs.spring.io/spring/docs/current/spring-framework-reference/integration.html#jms

simplifies the use of JMS, since it handles the creation and release of resources when sending or synchronously receiving messages.	

Code that uses the JmsTemplate needs only to implement callback interfaces that give them a clearly defined high-level contract. 

MessageCreator
--------------

The MessageCreator callback interface creates a message when given a Session provided by the calling code in JmsTemplate. 

The JMS API exposes two types of send methods:

1.  one that takes delivery mode, priority, and time-to-live as Quality of Service (QOS) parameters and 

2. one that takes no QOS parameters and uses default values. 

Since JmsTemplate has many send methods, setting the QOS parameters have been exposed as bean properties to avoid duplication in the number of send methods. Similarly, the timeout value for synchronous receive calls is set by using the setReceiveTimeout property.


================================================================================


	jmsTemlate with replyToQueue
	****************************

example here
https://www.ibm.com/developerworks/community/forums/html/topic?id=a28af5d5-c3a5-4f94-b040-b54d11833422


public JMSTextMessage sendAndRecieve(String request) {
        MQQueue requestQueue = new MQQueue("APP_REQUEST"); 
        MQQueue replyToQueue = new MQQueue("APP_REPLY");
 
JmsTemplate jmsTemplate = new JmsTemplate(jmsConnectionFactory);
        long recieveTimeout = 25000L

        jmsTemplate.setReceiveTimeout(recieveTimeout );
 
        String correlationId = getJmsCorrelationID();
        
        MessageCreator messageCreator = createMessageCreator(request,correlationId,replyToQueue);
        jmsTemplate.send(requestQueue,messageCreator);
 
        // use correlation id to ensure we get right msg
         JMSTextMessage message = (JMSTextMessage)jmsTemplate.receiveSelected(replyToQueue,"jms_correlationId='"+correlationId+"'");
 

        if (message == null) {
            long receiveTimeoutInSecs = receiveTimeout / 1000L;
            LOGGER.warn("Timeout of " + receiveTimeoutInSecs + " seconds exceeded while processing request.");
            handleTimeout(receiveTimeoutInSecs);
        } 
 
return message;
}


    private MessageCreator createMessageCreator(String request, String correlationId, Destination replyToQueue) {
        return new MessageCreator() {
            @Override
            public TextMessage createMessage(Session session) throws JMSException {                
                TextMessage message = session.createTextMessage();
                message.setStringProperty("JMS_IBM_Format", MQC.MQFMT_STRING);
                message.setStringProperty(JmsHeaders.MESSAGE_ID, correlationId);
                message.setStringProperty(JmsHeaders.CORRELATION_ID, correlationId);
                message.setJMSReplyTo(replyToQueue);
                message.setText(request);          
                return message;
            }
        };
    }



================================================================================

	mq-jms-spring-boot-starter
	**************************

Autoconfiguration:

META-INF/spring.factories


	org.springframework.boot.autoconfigure.EnableAutoConfiguration=com.ibm.mq.spring.boot.MQAutoConfiguration


Disabling autoconfiguration:
https://docs.spring.io/spring-boot/docs/current/reference/html/using-boot-auto-configuration.html

	If you find that specific auto-configuration classes that you do not want are being applied, you can use the exclude attribute of @EnableAutoConfiguration to disable them, as shown in the following example:

	import org.springframework.boot.autoconfigure.*;
	import org.springframework.boot.autoconfigure.jdbc.*;
	import org.springframework.context.annotation.*;

	@Configuration
	@EnableAutoConfiguration(exclude={DataSourceAutoConfiguration.class})
	public class MyConfiguration {

	}


================================================================================

	MQ JMS 
	******


	<parent>
		<groupId>org.springframework.boot</groupId>
		<artifactId>spring-boot-starter-parent</artifactId>
		<version>2.1.3.RELEASE</version>
		<relativePath/> <!-- lookup parent from repository -->
	</parent>

	<properties>

		<!-- build properties -->
		<project.build.sourceEncoding>UTF-8</project.build.sourceEncoding>

		<java.version>1.8</java.version>
		<maven.compiler.source>${java.version}</maven.compiler.source>
		<maven.compiler.target>${java.version}</maven.compiler.target>

		<jackson.version>2.9.8</jackson.version>
		<mq-jms-spring-boot-starter.version>2.1.0</mq-jms-spring-boot-starter.version>

	</properties>


		<dependency>
			<groupId>org.springframework.boot</groupId>
			<artifactId>spring-boot-starter-actuator</artifactId>
		</dependency>
		<dependency>
			<groupId>org.springframework.boot</groupId>
			<artifactId>spring-boot-starter-web</artifactId>
		</dependency>
		<dependency>
			<groupId>com.fasterxml.jackson.core</groupId>
			<artifactId>jackson-databind</artifactId>
			<version>${jackson.version}</version>
		</dependency>
		<dependency>
			<groupId>com.ibm.mq</groupId>
			<artifactId>mq-jms-spring-boot-starter</artifactId>
			<version>${mq-jms-spring-boot-starter.version}</version>
		</dependency>	


@SpringBootApplication
@RestController
@EnableJms
public class MqspringApplication {

	@Autowired
	private JmsTemplate jmsTemplate;

	public static void main(String[] args) {
		SpringApplication.run(MqspringApplication.class, args);
	}

	@GetMapping("send")
	String send() {
		try {
			jmsTemplate.convertAndSend("DEV.QUEUE", "Hello World");
			return "OK";
		} catch (JmsException ex) {
			ex.printStackTrace();
			return "FAIL";
		}
	}

	@GetMapping("recv")
	String recv() {
		try {
			return jmsTemplate.receiveAndConvert("DEV.QUEUE").toString();
		} catch (JmsException ex) {
			ex.printStackTrace();
			return "FAIL";
		}
	}
}


application.yml
---------------

spring.application.name: sb2-mq-jms

ibm.mq:
  queueManager: <queue-managger>
  channel: SYSTEM.ADMIN.SVRCONN
  connName: somehost(1414)
  user: 
  password: 


Issues
-------


org.springframework.boot.autoconfigure.jms.JmsPoolConnectionFactoryProperties

	Since 2.1.0


Support for multiple queues and queue managers
----------------------------------------------

https://github.com/ibm-messaging/mq-jms-spring/issues/7




================================================================================	

	spring boot configure multiple MQ conn factory instances
	********************************************************

https://stackoverflow.com/questions/43399072/spring-boot-configure-multiple-activemq-instances

How do I create multiple connectionFactories? 
How does JmsTemplate know which ActiveMQ instance to connect to?


================================================================================	

	Performance Considerations
	**************************

http://bjansen.github.io/java/2018/03/04/high-performance-mq-jms.html

Use non-persistent messages
---------------------------

Performance often comes at the cost of reliability. 
Depending on the requirements your application has, it can be acceptable to lose 
messages if the queue manager crashes.

a common misconception: there is no such thing as a persistent queue. 
Persistency is configured per message, and if a given message has no Persistence field set in its message descriptor (MQMD), then a queue can define a default persistence flag.

To send non persistent messages, specify a DeliveryMode when using a producer:

	// on the whole producer
	producer.setDeliveryMode(DeliveryMode.NON_PERSISTENT);

	// on a single message
	producer.send(message, DeliveryMode.NON_PERSISTENT, 3, 10000);

If you are using Spring JMS JmsTemplate, you need to enable explicit QOS and 
then st a default delivery mode:
https://stackoverflow.com/questions/36151558/activemq-with-spring-jms-how-to-sent-nonpersistent-message



jmsTemplate.setExplicitQosEnabled(true);
jmsTemplate.setDeliveryPersistent(false);


@Bean
public JmsTemplate jmsTemplate() throws NamingException {
    JmsTemplate jmsTemplate = new JmsTemplate();

    jmsTemplate.setConnectionFactory(queueConnectionFactory());
    jmsTemplate.setExplicitQosEnabled(true);
    jmsTemplate.setDeliveryPersistent(false);

    return jmsTemplate;
}



CachingConnectionFactory
-------------------------

make sure that you are reusing JMS objects as much as possible. 

Creating a connection or a session usually requires a network exchange, 
which means it can introduce a significant overhead. 

While the creation of producers and consumers has less overhead, itâ€™s good to know that these objets were designed to be reused, so you might as well take advantage of this and cache/reuse instances as much as possible.

If you are using Spring JMS, CachingConnectionFactory can wrap your connection factory to reuse a single connection, cache sessions and producers.

================================================================================	

  setJMSMessageId does nothing
  ****************************

https://stackoverflow.com/questions/56135309/spring-jmstemplate-setmessageid-is-overridden

  This method is for use by JMS providers only to set this field when a message is sent. This message cannot be used by clients to configure the message ID. This method is public to allow a JMS provider to set this field when sending a message whose implementation is not its own.

you have to set the JMS_IBM_MQMD_MsgId property and it will override the generated JMSMessageID


================================================================================  

  setting MQFMT_STRING format
  ****************************
  
TextMessage message = session.createTextMessage(stringWriter.toString());
message.setStringProperty(WMQConstants.JMS_IBM_FORMAT, MQConstants.MQFMT_STRING); 



================================================================================  

  set message ID for IBM MQ using java
  ************************************

https://www.ibm.com/support/knowledgecenter/en/SSFKSJ_9.1.0/com.ibm.mq.dev.doc/q032330_.htm
https://www-01.ibm.com/support/docview.wss?uid=swg27020570&aid=3


You control the ability to access the message descriptor (MQMD) by setting properties on a Destination and a Message.



https://stackoverflow.com/questions/19835743/cannot-set-the-property-value-for-jms-ibm-mqmd-msgid-in-weblogic-jms-java
For setObjectProperty:

The setObjectProperty method accepts values of class Boolean, Byte, Short, Integer, Long, Float, Double, and String. An attempt to use any other class must throw a JMSException.

So it does not accept ByteArray. setObjectProperty accepts Object so you don't get compile error.

--------------------------------------------------------------------------------


MQ V7 provides the following 2 JMS samples that do NOT use JNDI for the
specification of the Connection Factory and of the Destination (such as Queue).
These are the samples:
Unix:
/opt/mqm/samp/jms/samples/simple/SimpleMQMDWrite.java
/opt/mqm/samp/jms/samples/simple/SimpleMQMDRead.java
Windows:
C:\Program Files\IBM\WebSphere MQ\tools\jms\samples\simple\SimpleMQMDWrite.java
C:\Program Files\IBM\WebSphere MQ\tools\jms\samples\simple\SimpleMQMDRead.java



      // Enable write of MQMD fields. See documentation for further details.
      ((JmsDestination) destination).setBooleanProperty(WMQConstants.WMQ_MQMD_WRITE_ENABLED, true);

      // Set message context, if needed. See comment at the top.

      // Create a producer
      producer = session.createProducer(destination);

      // Create a message
      long uniqueNumber = System.currentTimeMillis() % 1000;
      TextMessage message = session
          .createTextMessage("SimpleMQMDWrite: Your lucky number today is " + uniqueNumber);

      // Generate a custom message id
      byte[] customMessageId = new byte[24];
      for (int i = 0; i < 24; i++) {
        // Hex-string 010203040506070801020304050607080102030405060708
        customMessageId[i] = (byte) ((i % 8) + 1);
      }

      // Write to MQMD.MsgId via JMS_IBM_MQMD_MSGID message property
      message.setObjectProperty(WMQConstants.JMS_IBM_MQMD_MSGID, customMessageId);


--------------------------------------------------------------------------------

SimpleMQMDWrite.java
-----------------------

// SCCSID "@(#) samples/jms/simple/SimpleMQMDWrite.java, jmscc.samples, k710, k710-007-151026  1.9.2.1 11/10/17 15:53:32"
/*
 * <N_OCO_COPYRIGHT>
 * Licensed Materials - Property of IBM
 * 
 * 5724-H72, 5655-R36, 5724-L26, 5655-L82     
 * 
 * (c) Copyright IBM Corp. 2008, 2009 All Rights Reserved.
 * 
 * US Government Users Restricted Rights - Use, duplication or
 * disclosure restricted by GSA ADP Schedule Contract with
 * IBM Corp.
 * <NOC_COPYRIGHT>
 */

package simple;

import javax.jms.Connection;
import javax.jms.Destination;
import javax.jms.JMSException;
import javax.jms.MessageProducer;
import javax.jms.Session;
import javax.jms.TextMessage;

import com.ibm.msg.client.jms.JmsConnectionFactory;
import com.ibm.msg.client.jms.JmsDestination;
import com.ibm.msg.client.jms.JmsFactoryFactory;
import com.ibm.msg.client.wmq.WMQConstants;

/**
 * A simple application that demonstrates how a JMS application may write MQ Message Descriptor
 * (MQMD) fields. No messages are received.
 * 
 * Application makes use of fixed literals, any customisations will require re-compilation of this
 * source file.
 * 
 * Notes:
 * 
 * API type: IBM JMS API (v1.1, unified domain)
 * 
 * Messaging domain: Point-to-point
 * 
 * Provider type: WebSphere MQ
 * 
 * Connection mode: Client connection
 * 
 * JNDI in use: No
 * 
 * Queue manager level assumed: v7 or above
 * 
 */
public class SimpleMQMDWrite {

  /*
   * The following note is based on MQMD_VERSION_2. For information about newer fields introduced by
   * a newer version of the MQMD structure, refer to the WebSphere MQ documentation.
   * 
   * Message context: Certain fields in MQMD contain the message context. There are two types of
   * message context -- identity context and origin context. Setting a MQMD field that contains the
   * message context requires the current user to have appropriate WebSphere MQ authority. For the
   * information about Message context, refer to the WebSphere MQ documentation.
   * 
   * Following fields can be set without setting the message context:
   * 
   * CodedCharSetId, CorrelId, Encoding, Expiry, Feedback, Format, GroupId, MsgFlags, MsgId,
   * MsgSeqNumber, MsgType, Offset, OriginalLength, Persistence, Priority, ReplyToQ, ReplyToQMgr,
   * Report.
   * 
   * Following fields require the identity context authority or, the superset, origin context
   * authority: AccountingToken, ApplIdentityData, UserIdentifier.
   * 
   * Following fields require the origin context authority: ApplOriginData, PutApplName,
   * PutApplType, PutDate, PutTime.
   * 
   * The identity context can be set in JMS by the following:
   * 
   * ((JmsDestination) destination).setIntProperty(WMQConstants.WMQ_MQMD_MESSAGE_CONTEXT,
   * WMQConstants.WMQ_MDCTX_SET_ALL_CONTEXT);
   * 
   * The origin context can be set in JMS by the following:
   * 
   * ((JmsDestination) destination).setIntProperty(WMQConstants.WMQ_MQMD_MESSAGE_CONTEXT,
   * WMQConstants.WMQ_MDCTX_SET_ALL_CONTEXT);
   * 
   * The identity context must be set in the above manner by setting a property on the destination
   * before the corresponding (identified) Producer object is instantiated.
   */

  // System exit status value (assume unset value to be 1)
  private static int status = 1;

  /**
   * Main method
   * 
   * @param args
   */
  public static void main(String[] args) {

    // Variables
    Connection connection = null;
    Session session = null;
    Destination destination = null;
    MessageProducer producer = null;

    try {
      // Create a connection factory
      JmsFactoryFactory ff = JmsFactoryFactory.getInstance(WMQConstants.WMQ_PROVIDER);
      JmsConnectionFactory cf = ff.createConnectionFactory();

      // Set the properties
      cf.setStringProperty(WMQConstants.WMQ_HOST_NAME, "localhost");
      cf.setIntProperty(WMQConstants.WMQ_PORT, 1414);
      cf.setStringProperty(WMQConstants.WMQ_CHANNEL, "SYSTEM.DEF.SVRCONN");
      cf.setIntProperty(WMQConstants.WMQ_CONNECTION_MODE, WMQConstants.WMQ_CM_CLIENT);
      cf.setStringProperty(WMQConstants.WMQ_QUEUE_MANAGER, "QM1");

      // Insist on queue manager level to be v7 or above
      cf.setStringProperty(WMQConstants.WMQ_PROVIDER_VERSION, "7.0.0.0");

      // Create JMS objects
      connection = cf.createConnection();
      session = connection.createSession(false, Session.AUTO_ACKNOWLEDGE);
      destination = session.createQueue("queue:///Q1");

      // Enable write of MQMD fields. See documentation for further details.
      ((JmsDestination) destination).setBooleanProperty(WMQConstants.WMQ_MQMD_WRITE_ENABLED, true);

      // Set message context, if needed. See comment at the top.

      // Create a producer
      producer = session.createProducer(destination);

      // Create a message
      long uniqueNumber = System.currentTimeMillis() % 1000;
      TextMessage message = session
          .createTextMessage("SimpleMQMDWrite: Your lucky number today is " + uniqueNumber);

      // Generate a custom message id
      byte[] customMessageId = new byte[24];
      for (int i = 0; i < 24; i++) {
        // Hex-string 010203040506070801020304050607080102030405060708
        customMessageId[i] = (byte) ((i % 8) + 1);
      }

      // Write to MQMD.MsgId via JMS_IBM_MQMD_MSGID message property
      message.setObjectProperty(WMQConstants.JMS_IBM_MQMD_MSGID, customMessageId);

      // Start the connection
      connection.start();

      // And, send the message
      producer.send(message);
      System.out.println("Sent message:\n" + message);

      recordSuccess();
    }
    catch (JMSException jmsex) {
      recordFailure(jmsex);
    }
    finally {
      if (producer != null) {
        try {
          producer.close();
        }
        catch (JMSException jmsex) {
          System.out.println("Producer could not be closed.");
          recordFailure(jmsex);
        }
      }

      if (session != null) {
        try {
          session.close();
        }
        catch (JMSException jmsex) {
          System.out.println("Session could not be closed.");
          recordFailure(jmsex);
        }
      }

      if (connection != null) {
        try {
          connection.close();
        }
        catch (JMSException jmsex) {
          System.out.println("Connection could not be closed.");
          recordFailure(jmsex);
        }
      }
    }
    System.exit(status);
    return;
  } // end main()

  /**
   * Process a JMSException and any associated inner exceptions.
   * 
   * @param jmsex
   */
  private static void processJMSException(JMSException jmsex) {
    System.out.println(jmsex);
    Throwable innerException = jmsex.getLinkedException();
    if (innerException != null) {
      System.out.println("Inner exception(s):");
    }
    while (innerException != null) {
      System.out.println(innerException);
      innerException = innerException.getCause();
    }
    return;
  }

  /**
   * Record this run as successful.
   */
  private static void recordSuccess() {
    System.out.println("SUCCESS");
    status = 0;
    return;
  }

  /**
   * Record this run as failure.
   * 
   * @param ex
   */
  private static void recordFailure(Exception ex) {
    if (ex != null) {
      if (ex instanceof JMSException) {
        processJMSException((JMSException) ex);
      }
      else {
        System.out.println(ex);
      }
    }
    System.out.println("FAILURE");
    status = -1;
    return;
  }

}





================================================================================  