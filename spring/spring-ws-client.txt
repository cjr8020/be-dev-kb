	@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
	
		Spring Rest Clients

	@@@@@@@@@@@@@@@@@@@@@@@@@@@@@



    RestTemplate vs straight Apache HttpClient
    ******************************************

RestTemplate is very simple to use, but for most production cases, other than the
most basic ones, you will most likely to use Apache HttpClient.

RestTemplate creats a new HttpConnection every time, so if you need any kind of 
connection pool management, you will need Apache HttpClient.

HttpClient exposes a very flexibile API for configuring connection pooling, etc.

You can use HttpClient for handling client connections to different APIs.
These APIs require different Basic Auth credentials or different AuthN schemes.

If you want to use RestTemplate:

1. you can use RestTemplate and handle the authentication manually by adding 
Headers, or

2. you will need to have a different instance of RestTemplate bean for different
APIs.

RestTemplateBuilder, RestTemplateCustomizer

You can tecnically customize RestTemplate to varying degrees with RestTemplateBuilder or
RestTemplateCustomizer
https://docs.spring.io/spring-boot/docs/current/reference/html/boot-features-resttemplate.html


However, when all things considered it sounds like it would be just easier to 
use HttpClient by itself in each particular ServiceXClient class.



================================================================================

	Apache HttpClient
	*****************

Configuring 
------------------------------------
http://www.baeldung.com/httpclient-connection-management
https://hc.apache.org/httpcomponents-client-ga/tutorial/html/connmgmt.html

The defaults of the pooling connection manager are well chosen but 
depending on your use case – may be too small:

defaults:

	the per host connection limit is 2 by default
    up to 20 connections in total


    PoolingHttpClientConnectionManager cm = new PoolingHttpClientConnectionManager();


You can configure:
setMaxTotal(int max): 
    Set the maximum number of total open connections.

setDefaultMaxPerRoute(int max): 
    Set the maximum number of concurrent connections per route, 
    which is 2 by default.

setMaxPerRoute(int max): 
    Set the total number of concurrent connections to a specific route, 
    which is 2 by default.


Examples:    

the total number of connections

    // increase max total connections
    cm.setMaxTotal(50);

the maximum number of connections per (any) route

    // increase default max connections per route to 5
    cm.setDefaultMaxPerRoute(5);

the maximum number of connections per a single, specific route:

    // increase max connections for localhost:80 to 20
    HttpHost localhost = new HttpHost("localhost", 80);
    cm.setMaxPerRoute(new HttpRoute(localhost), 20);


================================================================================

HttpClientConfig.class
----------------------

import java.security.KeyManagementException;
import java.security.KeyStoreException;
import java.security.NoSuchAlgorithmException;
import java.util.concurrent.TimeUnit;

import org.apache.http.HeaderElement;
import org.apache.http.HeaderElementIterator;
import org.apache.http.HttpResponse;
import org.apache.http.client.config.RequestConfig;
import org.apache.http.config.Registry;
import org.apache.http.config.RegistryBuilder;
import org.apache.http.conn.ConnectionKeepAliveStrategy;
import org.apache.http.conn.socket.ConnectionSocketFactory;
import org.apache.http.conn.socket.PlainConnectionSocketFactory;
import org.apache.http.conn.ssl.SSLConnectionSocketFactory;

import org.apache.http.conn.ssl.TrustSelfSignedStrategy;
import org.apache.http.impl.client.CloseableHttpClient;
import org.apache.http.impl.client.HttpClients;
import org.apache.http.impl.conn.PoolingHttpClientConnectionManager;
import org.apache.http.message.BasicHeaderElementIterator;
import org.apache.http.protocol.HTTP;
import org.apache.http.protocol.HttpContext;
import org.apache.http.ssl.SSLContextBuilder;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;
import org.springframework.context.annotation.Bean;
import org.springframework.context.annotation.Configuration;
import org.springframework.scheduling.annotation.EnableScheduling;
import org.springframework.scheduling.annotation.Scheduled;

/**
 * - Supports both HTTP and HTTPS
 * - Uses a connection pool to re-use connections and save overhead of creating connections.
 * - Has a custom connection keep-alive strategy (to apply a default keep-alive if one isn't specified)
 * - Starts an idle connection monitor to continuously clean up stale connections.
 */
@Configuration
@EnableScheduling
public class HttpClientConfig {

    private static final Logger LOGGER = LoggerFactory.getLogger(HttpClientConfig.class);

    // Determines the timeout in milliseconds until a connection is established.
    private static final int CONNECT_TIMEOUT = 30000;
    
    // The timeout when requesting a connection from the connection manager.
    private static final int REQUEST_TIMEOUT = 30000;
    
    // The timeout for waiting for data
    private static final int SOCKET_TIMEOUT = 60000;

    private static final int MAX_TOTAL_CONNECTIONS = 50;
    private static final int DEFAULT_KEEP_ALIVE_TIME_MILLIS = 20 * 1000;
    private static final int CLOSE_IDLE_CONNECTION_WAIT_TIME_SECS = 30;

    @Bean
    public PoolingHttpClientConnectionManager poolingConnectionManager() {
        SSLContextBuilder builder = new SSLContextBuilder();
        try {
            builder.loadTrustMaterial(null, new TrustSelfSignedStrategy());
        } catch (NoSuchAlgorithmException | KeyStoreException e) {
            LOGGER.error("Pooling Connection Manager Initialisation failure because of " + e.getMessage(), e);
        }

        SSLConnectionSocketFactory sslsf = null;
        try {
            sslsf = new SSLConnectionSocketFactory(builder.build());
        } catch (KeyManagementException | NoSuchAlgorithmException e) {
            LOGGER.error("Pooling Connection Manager Initialisation failure because of " + e.getMessage(), e);
        }

        Registry<ConnectionSocketFactory> socketFactoryRegistry = RegistryBuilder
                .<ConnectionSocketFactory>create().register("https", sslsf)
                .register("http", new PlainConnectionSocketFactory())
                .build();

        PoolingHttpClientConnectionManager poolingConnectionManager = new PoolingHttpClientConnectionManager(socketFactoryRegistry);
        poolingConnectionManager.setMaxTotal(MAX_TOTAL_CONNECTIONS);
        return poolingConnectionManager;
    }

    @Bean
    public ConnectionKeepAliveStrategy connectionKeepAliveStrategy() {
        return new ConnectionKeepAliveStrategy() {
            @Override
            public long getKeepAliveDuration(HttpResponse response, HttpContext context) {
                HeaderElementIterator it = new BasicHeaderElementIterator
                        (response.headerIterator(HTTP.CONN_KEEP_ALIVE));
                while (it.hasNext()) {
                    HeaderElement he = it.nextElement();
                    String param = he.getName();
                    String value = he.getValue();

                    if (value != null && param.equalsIgnoreCase("timeout")) {
                        return Long.parseLong(value) * 1000;
                    }
                }
                return DEFAULT_KEEP_ALIVE_TIME_MILLIS;
            }
        };
    }

    @Bean
    public CloseableHttpClient httpClient() {
        RequestConfig requestConfig = RequestConfig.custom()
                .setConnectionRequestTimeout(REQUEST_TIMEOUT)
                .setConnectTimeout(CONNECT_TIMEOUT)
                .setSocketTimeout(SOCKET_TIMEOUT).build();

        return HttpClients.custom()
                .setDefaultRequestConfig(requestConfig)
                .setConnectionManager(poolingConnectionManager())
                .setKeepAliveStrategy(connectionKeepAliveStrategy())
                .build();
    }
    
    @Bean
    public Runnable idleConnectionMonitor(final PoolingHttpClientConnectionManager connectionManager) {
        return new Runnable() {
            @Override
            @Scheduled(fixedDelay = 10000)
            public void run() {
                try {
                    if (connectionManager != null) {
                        LOGGER.trace("run IdleConnectionMonitor - Closing expired and idle connections...");
                        connectionManager.closeExpiredConnections();
                        connectionManager.closeIdleConnections(CLOSE_IDLE_CONNECTION_WAIT_TIME_SECS, TimeUnit.SECONDS);
                    } else {
                        LOGGER.trace("run IdleConnectionMonitor - Http Client Connection manager is not initialised");
                    }
                } catch (Exception e) {
                    LOGGER.error("run IdleConnectionMonitor - Exception occurred. msg={}, e={}", e.getMessage(), e);
                }
            }
        };
    }

}

--------------------------------------------------------------------------------
pom.xml
---------


        <dependency>
            <groupId>org.springframework.boot</groupId>
            <artifactId>spring-boot-starter-web</artifactId>
        </dependency>
        <dependency>
            <groupId>org.springframework.boot</groupId>
            <artifactId>spring-boot-starter-hateoas</artifactId>
        </dependency>
         
        <dependency>
            <groupId>org.springframework.boot</groupId>
            <artifactId>spring-boot-starter-test</artifactId>
        </dependency>
        <dependency>
            <groupId>org.apache.httpcomponents</groupId>
            <artifactId>httpclient</artifactId>
        </dependency>



================================================================================

	Sample Configuration for HttpClient
	***********************************


https://stackoverflow.com/questions/29959772/spring-configurable-high-performance-metered-http-client-instances


@Configuration
public class HttpClientConfiguration {

  private static final Logger log = LoggerFactory.getLogger(HttpClientConfiguration.class);

  @Autowired
  private Environment environment;

  @Bean
  public ClientHttpRequestFactory httpRequestFactory() {
    return new HttpComponentsClientHttpRequestFactory(httpClient());
  }

  @Bean
  public RestTemplate restTemplate() {
    RestTemplate restTemplate = new RestTemplate(httpRequestFactory());
    restTemplate.setInterceptors(ImmutableList.of((request, body, execution) -> {
      byte[] token = Base64.encodeBase64((format("%s:%s", environment.getProperty("fake.username"), environment.getProperty("fake.password"))).getBytes());
      request.getHeaders().add("Authorization", format("Basic %s", new String(token)));

      return execution.execute(request, body);
    }));

    return restTemplate;
  }

  @Bean
  public HttpClient httpClient() {
    PoolingHttpClientConnectionManager connectionManager = new PoolingHttpClientConnectionManager();

    // Get the poolMaxTotal value from our application[-?].yml or default to 10 if not explicitly set
    connectionManager.setMaxTotal(environment.getProperty("poolMaxTotal", Integer.class, 10));

    return HttpClientBuilder
      .create()
      .setConnectionManager(connectionManager)
      .build();
  }

  /**
   * Just for demonstration
   */
  @PostConstruct
  public void debug() {
    log.info("Pool max total: {}", environment.getProperty("poolMaxTotal", Integer.class));
  }
}


and an example application.yml
-------------------------------

fake.username: test
fake.password: test
poolMaxTotal: 10


To support different values per environment you can use Spring profiles. Using the example above, you could just create application-prod.yml with a "prod" specific value for poolMaxTotal. Then start your app with --spring.profiles.active=prod and the "prod" value will be used instead of your default value in application.yml. You can do this for however many environments you need.

application-prod.yml

poolMaxTotal: 20



================================================================================

	Connection Keep-Alive Strategy
	******************************

what is keep-alive?  https://blog.stackpath.com/glossary/keep-alive/


http://www.baeldung.com/httpclient-connection-management

Quoting the HttpClient 4.3.3. reference: 
http://hc.apache.org/httpcomponents-client-ga/tutorial/html/connmgmt.html#d5e373

	“If the Keep-Alive header is not present in the response, HttpClient assumes the connection can be kept alive indefinitely.” 

To get around this, and be able to manage dead connections we need a customized strategy implementation and build it into the HttpClient.

Custom keep-alive strategy:

	first try to apply the host's Keep-Alive policy stated in the header.
	if that information is not present in the response header, keep connection
	alive for 5 seconds


ConnectionKeepAliveStrategy myStrategy = new ConnectionKeepAliveStrategy() {
    @Override
    public long getKeepAliveDuration(HttpResponse response, HttpContext context) {
        HeaderElementIterator it = new BasicHeaderElementIterator
            (response.headerIterator(HTTP.CONN_KEEP_ALIVE));
        while (it.hasNext()) {
            HeaderElement he = it.nextElement();
            String param = he.getName();
            String value = he.getValue();
            if (value != null && param.equalsIgnoreCase
               ("timeout")) {
                return Long.parseLong(value) * 1000;
            }
        }
        return 5 * 1000;
    }
};

Now, configure the client to use this custom strategy:

	PoolingHttpClientConnectionManager connManager 
	  = new PoolingHttpClientConnectionManager();
	CloseableHttpClient client = HttpClients.custom()
	  .setKeepAliveStrategy(myStrategy)
	  .setConnectionManager(connManager)
	  .build();




================================================================================

	IdleConnectionMonitorThread 
	***************************

Connection Eviction

Connection eviction is used to detect idle and expired connections and close them; there are two options to do this.

1. Relying on the HttpClient to check if the connection is stale before executing a   
   request. This is an expensive option that is not always reliable.

2. Create a monitor thread to close idle and/or closed connections.


1. Setting the HttpClient to check for Stale Connections
---------------------------------------------------------

	PoolingHttpClientConnectionManager connManager 
	  = new PoolingHttpClientConnectionManager();
	
	CloseableHttpClient client 
			= HttpClients.custom()
				.setDefaultRequestConfig(
	    			RequestConfig.custom()
	    				.setStaleConnectionCheckEnabled(true)
	    				.build()
	).setConnectionManager(connManager).build();


2. Use a Stale Connection Monitor Thread
-----------------------------------------

	PoolingHttpClientConnectionManager connManager 
	  = new PoolingHttpClientConnectionManager();
	
	CloseableHttpClient client 
			= HttpClients.custom()
	  			.setConnectionManager(connManager)
	  			.build();

	IdleConnectionMonitorThread staleMonitor
	 = new IdleConnectionMonitorThread(connManager);
	staleMonitor.start();
	staleMonitor.join(1000);


	IdleConnectionMonitorThread.class
--------------------------------------

	public class IdleConnectionMonitorThread extends Thread {
	    private final HttpClientConnectionManager connMgr;
	    private volatile boolean shutdown;
	 
	    public IdleConnectionMonitorThread(
	      PoolingHttpClientConnectionManager connMgr) {
	        super();
	        this.connMgr = connMgr;
	    }
	    @Override
	    public void run() {
	        try {
	            while (!shutdown) {
	                synchronized (this) {
	                    wait(1000);
	                    connMgr.closeExpiredConnections();
	                    connMgr.closeIdleConnections(30, TimeUnit.SECONDS);
	                }
	            }
	        } catch (InterruptedException ex) {
	            shutdown();
	        }
	    }
	    public void shutdown() {
	        shutdown = true;
	        synchronized (this) {
	            notifyAll();
	        }
	    }
	}		




================================================================================

    Apache HttpClient with SSL "Accept All" support
    ***********************************************

how to configure SSL for an Apache HttpClient so that it is able to consume any HTTPS URL, 
regardless of the certificate.   

!!!  this strategy entirely ignores certificate checking  !!!

    https://www.baeldung.com/httpclient-ssl

HttpClient 4.4+


    SSLContext sslContext = new SSLContextBuilder()
      .loadTrustMaterial(null, (certificate, authType) -> true).build();
 
    CloseableHttpClient client = HttpClients.custom()
      .setSSLContext(sslContext)
      .setSSLHostnameVerifier(new NoopHostnameVerifier())
      .build();
    HttpGet httpGet = new HttpGet(HOST_WITH_SSL);
    httpGet.setHeader("Accept", "application/xml");

    client.execute(httpGet);

RestTemplate with SSL (HttpClient 4.4+)

    CloseableHttpClient httpClient = HttpClients.custom()
        .setSSLHostnameVerifier(new NoopHostnameVerifier())
        .build();

    HttpComponentsClientHttpRequestFactory requestFactory 
      = new HttpComponentsClientHttpRequestFactory();
    requestFactory.setHttpClient(httpClient);
 
    ResponseEntity<String> response 
      = new RestTemplate(requestFactory).exchange(
      urlOverHttps, HttpMethod.GET, null, String.class);



================================================================================

    Apache HttpClient with custom SSL context
    *****************************************

https://stackoverflow.com/questions/27724544/specifying-trust-store-information-in-spring-boot-application-properties

Configuring RestTemplate for Client TLS in a Spring Boot Application
https://gist.github.com/serac/4f77e42c1ac515114a1c8e9469be25ad

https://hc.apache.org/httpcomponents-client-ga/httpclient/examples/org/apache/http/examples/client/ClientCustomSSL.java


[ref = https://stackoverflow.com/questions/27724544/specifying-trust-store-information-in-spring-boot-application-properties]
--------------------------------------------------------------------------------    
import org.apache.http.client.HttpClient;
import org.apache.http.conn.ssl.NoopHostnameVerifier;
import org.apache.http.conn.ssl.SSLConnectionSocketFactory;
import org.apache.http.conn.ssl.TrustSelfSignedStrategy;
import org.apache.http.impl.client.HttpClients;
import org.apache.http.ssl.SSLContexts;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.beans.factory.annotation.Value;
import org.springframework.core.io.Resource;
import org.springframework.http.client.HttpComponentsClientHttpRequestFactory;
import org.springframework.web.client.RestTemplate;

@Value("${http.client.ssl.key-store}")
private Resource keyStore;

@Value("${http.client.ssl.trust-store}")
private Resource trustStore;

// I use the same pw for both keystores:
@Value("${http.client.ssl.trust-store-password}")
private String keyStorePassword;

// wasn't able to provide this as a @Bean...:
private RestTemplate getRestTemplate() {
  try {
    SSLContext sslContext = SSLContexts.custom()
        // keystore wasn't within the question's scope, yet it might be handy:
        .loadKeyMaterial(
            keyStore.getFile(),
            keyStorePassword.toCharArray(),
            keyStorePassword.toCharArray())
        .loadTrustMaterial(
            trustStore.getURL(),
            keyStorePassword.toCharArray(),
            // use this for self-signed certificates only:
            new TrustSelfSignedStrategy())
        .build();

    HttpClient httpClient = HttpClients.custom()
        // use NoopHostnameVerifier with caution, see https://stackoverflow.com/a/22901289/3890673
        .setSSLSocketFactory(new SSLConnectionSocketFactory(sslContext, new NoopHostnameVerifier()))
        .build();

    return new RestTemplate(new HttpComponentsClientHttpRequestFactory(httpClient));
  } catch (IOException | GeneralSecurityException e) {
    throw new RuntimeException(e);
  }
}

================================================================================


    Concrete HttpClientConfiguration example
    ****************************************

used in a SB service



package com.company.service.configuration;

import java.io.File;
import java.io.FileInputStream;
import java.io.IOException;
import java.security.KeyManagementException;
import java.security.KeyStore;
import java.security.KeyStoreException;
import java.security.NoSuchAlgorithmException;
import java.security.UnrecoverableKeyException;
import java.security.cert.CertificateException;
import java.util.Arrays;
import java.util.concurrent.TimeUnit;
import javax.annotation.PostConstruct;
import javax.net.ssl.SSLContext;
import org.apache.http.HeaderElement;
import org.apache.http.HeaderElementIterator;
import org.apache.http.HttpResponse;
import org.apache.http.client.config.RequestConfig;
import org.apache.http.config.Registry;
import org.apache.http.config.RegistryBuilder;
import org.apache.http.conn.ConnectionKeepAliveStrategy;
import org.apache.http.conn.socket.ConnectionSocketFactory;
import org.apache.http.conn.socket.PlainConnectionSocketFactory;
import org.apache.http.conn.ssl.SSLConnectionSocketFactory;
import org.apache.http.impl.client.CloseableHttpClient;
import org.apache.http.impl.client.HttpClients;
import org.apache.http.impl.conn.PoolingHttpClientConnectionManager;
import org.apache.http.message.BasicHeaderElementIterator;
import org.apache.http.protocol.HTTP;
import org.apache.http.protocol.HttpContext;
import org.apache.http.ssl.SSLContexts;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;
import org.springframework.beans.factory.annotation.Value;
import org.springframework.context.annotation.Bean;
import org.springframework.context.annotation.Configuration;
import org.springframework.scheduling.annotation.EnableScheduling;
import org.springframework.scheduling.annotation.Scheduled;

/**
 * Provides configuration for Apache HTTP client. HTTP client provides connection support for all
 * REST service client in this application including - TLS support - connection pooling - connection
 * keep-alive strategy - idle connection monitoring
 */
@Configuration
@EnableScheduling
public class HttpClientConfiguration {

  private static final Logger logger = LoggerFactory.getLogger(HttpClientConfiguration.class);

  /**
   * Connection request timeout (ms). The amount of time to wait for a connection from a connection
   * manager/pool.
   */
  @Value("${app.http-client.connection-request-timeout:30000}")
  private int connectionRequestTimeout;

  /**
   * Connection timeout (ms). The time to establish the connection with the remote host.
   */
  @Value("${app.http-client.connection-timeout:30000}")
  private int connectionTimeout;

  /**
   * Connection socket timeout (ms). The time waiting for data – after the connection was
   * established. The maximum time of inactivity between two data packets.
   */
  @Value("${app.http-client.connection-socket-timeout:30000}")
  private int connectionSocketTimeout;

  /**
   * Max number of connection in the connection pool for all routes.
   */
  @Value("${app.http-client.connection-pool-max-total:20}")
  private int connectionPoolMaxTotal;

  /**
   * Max number of connections per route (for a specific server).
   */
  @Value("${app.http-client.connection-pool-max-max-per-route:2}")
  private int connectionPoolMaxPerRoute;

  /**
   * Wait time (seconds) before closing idle connections.
   */
  @Value("${app.http-client.close-idle-connections-wait:30}")
  private int closeIdleConnectionsWait;

  /**
   * Default keep-alive time (ms) if Keep-Alive header is not present in the response.
   */
  @Value("${app.http-client.connection-keep-alive-default:50000}")
  private int connectionKeepAliveDefault;

  /**
   * TLS configuration.
   */
  @Value("${app.http-client.tls.supported-protocols}")
  private String[] supportedProtocols;
  @Value("${app.http-client.tls.key-store}")
  private String keyStorePath;
  @Value("${app.http-client.tls.key-store-password}")
  private String keyStorePassword;
  @Value("${app.http-client.tls.key-store-type:JKS}")
  private String keyStoreType;
  @Value("${app.http-client.tls.trust-store}")
  private String trustStorePath;
  @Value("${app.http-client.tls.trust-store-password}")
  private String trustStorePassword;
  @Value("${app.http-client.tls.trust-store-type:JKS}")
  private String trustStoreType;


  /**
   * Post construct logger.
   */
  @PostConstruct
  public void configurationProperties() {
    logger.warn("HTTP Client configuration settings:");
    logger.warn("connectionRequestTimeout = {}ms", connectionRequestTimeout);
    logger.warn("connectionTimeout = {}ms", connectionTimeout);
    logger.warn("connectionSocketTimeout = {}ms", connectionSocketTimeout);
    logger.warn("connectionPoolMaxTotal = {}", connectionPoolMaxTotal);
    logger.warn("connectionPoolMaxPerRoute = {}", connectionPoolMaxPerRoute);
    logger.warn("closeIdleConnectionsWait = {}sec", closeIdleConnectionsWait);
    logger.warn("connectionKeepAliveDefault = {}ms", connectionKeepAliveDefault);
    // tls
    logger.warn("supportedProtocols = {}", Arrays.toString(supportedProtocols));
    logger.warn("keyStorePath = {}", keyStorePath);
    logger.warn("keyStoreType = {}", keyStoreType);
    logger.warn("trustStorePath = {}", trustStorePath);
    logger.warn("trustStoreType = {}", trustStoreType);
  }


  /**
   * Keep-alive strategy bean.
   *
   * @return ConnectionKeepAliveStrategy
   */
  @Bean
  public ConnectionKeepAliveStrategy connectionKeepAliveStrategy() {
    return new ConnectionKeepAliveStrategy() {

      /**
       * Returns the duration of time which this connection can be safely kept
       * idle. If the connection is left idle for longer than this period of time,
       * it MUST not reused. A value of 0 or less may be returned to indicate that
       * there is no suitable suggestion.
       *
       * <p>When coupled with a {@link org.apache.http.ConnectionReuseStrategy}, if
       * {@link org.apache.http.ConnectionReuseStrategy#keepAlive(
       *HttpResponse, HttpContext)} returns true, this allows you to control
       * how long the reuse will last. If keepAlive returns false, this should
       * have no meaningful impact.
       *
       * @param response
       *            The last response received over the connection.
       * @param context
       *            the context in which the connection is being used.
       *
       * @return the duration in ms for which it is safe to keep the connection
       *         idle, or &lt;=0 if no suggested duration.
       */
      @Override
      public long getKeepAliveDuration(HttpResponse response, HttpContext context) {
        HeaderElementIterator it
            = new BasicHeaderElementIterator(response.headerIterator(HTTP.CONN_KEEP_ALIVE));
        while (it.hasNext()) {
          HeaderElement he = it.nextElement();
          String param = he.getName();
          String value = he.getValue();

          if (value != null && param.equalsIgnoreCase("timeout")) {
            return Long.parseLong(value) * 1000;
          }
        }
        return connectionKeepAliveDefault;
      }
    };
  }

  /**
   * Idle connection monitor.
   *
   * @param connectionManager PoolingHttpClientConnectionManager
   * @return Runnable
   */
  @Bean
  public Runnable idleConnectionMonitor(
      final PoolingHttpClientConnectionManager connectionManager) {
    return new Runnable() {
      @Override
      @Scheduled(fixedDelay = 10000)
      public void run() {
        try {
          if (connectionManager != null) {
            logger.trace("run IdleConnectionMonitor - Closing expired and idle connections...");
            connectionManager.closeExpiredConnections();
            connectionManager.closeIdleConnections(closeIdleConnectionsWait, TimeUnit.SECONDS);
          } else {
            logger.trace(
                "run IdleConnectionMonitor - Http Client Connection manager is not initialised");
          }
        } catch (Exception e) {
          logger
              .error("run IdleConnectionMonitor - Exception occurred. msg={}, e={}", e.getMessage(),
                  e);
        }
      }
    };
  }


  /**
   * ClientConnectionPoolManager maintains a pool of HttpClientConnections and is able to service
   * connection requests from multiple execution threads.
   *
   * @return PoolingHttpClientConnectionManager
   */
  @Bean
  public PoolingHttpClientConnectionManager poolingConnectionManager() {

    SSLConnectionSocketFactory sslSocketFactory = null;

    try {
      sslSocketFactory = new SSLConnectionSocketFactory(
          customSslContext(),
          supportedProtocols,
          null,
          SSLConnectionSocketFactory.getDefaultHostnameVerifier()
      );
    } catch (IOException
        | KeyStoreException
        | CertificateException
        | NoSuchAlgorithmException
        | UnrecoverableKeyException
        | KeyManagementException exception) {
      throw new IllegalStateException("Error loading key or trust store.", exception);
    }

    Registry<ConnectionSocketFactory> socketFactoryRegistry
        = RegistryBuilder.<ConnectionSocketFactory>create()
        .register("http", PlainConnectionSocketFactory.getSocketFactory())
        .register("https", sslSocketFactory)
        .build();

    PoolingHttpClientConnectionManager poolingConnectionManager
        = new PoolingHttpClientConnectionManager(socketFactoryRegistry);
    poolingConnectionManager.setMaxTotal(connectionPoolMaxTotal);
    return poolingConnectionManager;
  }


  /**
   * Apache HTTP Client implementation.
   *
   * @return CloseableHttpClient
   */
  @Bean
  public CloseableHttpClient httpClient() {
    RequestConfig requestConfig = RequestConfig.custom()
        .setConnectionRequestTimeout(connectionRequestTimeout)
        .setConnectTimeout(connectionTimeout)
        .setSocketTimeout(connectionSocketTimeout).build();

    return HttpClients.custom()
        .setDefaultRequestConfig(requestConfig)
        .setConnectionManager(poolingConnectionManager())
        .setKeepAliveStrategy(connectionKeepAliveStrategy())
        .build();
  }



  /**
   * Custom SSL Context using provided keystore and truststore.
   *
   * @return SSLContext
   * @throws IOException IOException
   * @throws KeyStoreException KeyStoreException
   * @throws CertificateException CertificateException
   * @throws NoSuchAlgorithmException NoSuchAlgorithmException
   * @throws UnrecoverableKeyException UnrecoverableKeyException
   * @throws KeyManagementException KeyManagementException
   */
  @Bean
  public SSLContext customSslContext()
      throws IOException, KeyStoreException, CertificateException, NoSuchAlgorithmException,
      UnrecoverableKeyException, KeyManagementException {

    final KeyStore keyStore;
    final KeyStore trustStore;

    try (
        FileInputStream keyStoreInputStream = new FileInputStream(new File(keyStorePath));
        FileInputStream trustStoreInputStream = new FileInputStream(new File(trustStorePath))) {
      keyStore = KeyStore.getInstance(keyStoreType);
      keyStore.load(keyStoreInputStream, keyStorePassword.toCharArray());
      trustStore = KeyStore.getInstance(trustStoreType);
      trustStore.load(trustStoreInputStream, trustStorePassword.toCharArray());
    }

    return SSLContexts.custom()
        .loadKeyMaterial(keyStore, keyStorePassword.toCharArray(), (aliases, socket) -> "keyStore")
        .loadTrustMaterial(trustStore, (x509Certificates, s) -> false)
        .build();
  }

}


consume the above HttpClientConfiguration in a specific HTTP service client
----------------------------------------------------------------------------

SomeApiClient.java
-------------------


import com.fasterxml.jackson.annotation.JsonInclude;
import com.fasterxml.jackson.core.type.TypeReference;
import com.fasterxml.jackson.databind.DeserializationFeature;
import com.fasterxml.jackson.databind.ObjectMapper;
import com.acme.service.shared.exceptions.DownstreamServiceException;
import com.standard.sfg.audit.ExecutionContextHolder;
import com.standard.sfg.audit.springboot.SfgAuditableFactory.SfgAuditor;
import java.io.IOException;
import java.io.UnsupportedEncodingException;
import java.net.URI;
import java.net.URISyntaxException;
import java.nio.charset.Charset;
import java.security.InvalidKeyException;
import java.security.NoSuchAlgorithmException;
import java.time.ZonedDateTime;
import java.time.format.DateTimeFormatter;
import java.util.HashMap;
import java.util.Map;
import java.util.Optional;
import java.util.regex.Matcher;
import java.util.regex.Pattern;
import org.apache.http.HttpHeaders;
import org.apache.http.client.methods.CloseableHttpResponse;
import org.apache.http.client.methods.HttpDelete;
import org.apache.http.client.methods.HttpGet;
import org.apache.http.client.methods.HttpPost;
import org.apache.http.client.methods.HttpPut;
import org.apache.http.client.protocol.HttpClientContext;
import org.apache.http.client.utils.URIBuilder;
import org.apache.http.entity.StringEntity;
import org.apache.http.impl.client.CloseableHttpClient;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.stereotype.Component;
import org.springframework.util.StopWatch;


/**
 * Some API client.
 */
@Component
public class SomeApiClient {


  private CloseableHttpClient httpClient;
  private SomeApiConfiguration someApiConfig;
  private SfgAuditor sfgAuditor;
  private ObjectMapper objectMapper;


  /**
   * Constructor.
   */
  @Autowired
  public SomeApiClient(
      final CloseableHttpClient httpClient,
      final SomeApiConfiguration someApiConfiguration,
      final Auditor myAuditor
  ) {
    this.httpClient = httpClient;
    this.someApiConfig = someApiConfiguration;
    this.myAuditor = myAuditor;

    objectMapper = new ObjectMapper()
        .configure(DeserializationFeature.FAIL_ON_UNKNOWN_PROPERTIES, false);
    objectMapper.setSerializationInclusion(JsonInclude.Include.NON_EMPTY);
  }



  /*
   * -------------------------------------------------------------------------
   *  Public interface.
   * -------------------------------------------------------------------------
   */


  public void callSomeSomething(final String uuid, final String blah) {
    final StopWatch sw = new StopWatch();

    try {
      sw.start();
      final URIBuilder uriBuilder = new URIBuilder();
      uriBuilder
          .setScheme(someApiConfig.getScheme())
          .setHost(someApiConfig.getHost())
          .setPort(someApiConfig.getPort())
          .setPath(String.format(TEMPLATE, uuid));

      String requestBody = objectMapper.writeValueAsString(new Blah(blah));

      // headers
      Map<String, String> headers = getHeaders(
          "POST",
          uriBuilder.toString(),
          requestBody
      );

      HttpPost request = setupHttpPostRequest(
          uriBuilder,
          Optional.empty(),
          Optional.of(headers));
      request.setEntity(new StringEntity(requestBody));
      final HttpClientContext context = HttpClientContext.create();

      if (logger.isInfoEnabled()) {
        logger.info(
            "{}, method=doSomething, uuid={}, update request={}",
            auditor.auditableLogMessage(ExecutionContextHolder.get()),
            uuid,
            requestBody);
      }

      // call
      try (CloseableHttpResponse httpResponse = this.httpClient.execute(request, context)) {

        int httpStatusCode = httpResponse.getStatusLine().getStatusCode();
        if (httpStatusCode == 201) {  // 201 Created
          if (logger.isInfoEnabled()) {
            logger.info("{}, doSomething: success",
                myAuditor.auditableLogMessage(ExecutionContextHolder.get()));
          }
        } else {
          Map<String, Object> errorResponse = objectMapper.readValue(
              httpResponse.getEntity().getContent(),
              new TypeReference<Map<String, Object>>() {
              });
          String message = "Error response from  API server."
              + " HTTP status code=" + httpStatusCode
              + " error response=" + errorResponse;
          logger.error(message);
          throw new DownstreamServiceException(message);
        }
      }

    } catch (URISyntaxException exception) {
      String message
          = "method=doSomething, original exception=" + exception;
      logger.error(
          "{}, {}",
          auditor.auditableLogMessage(ExecutionContextHolder.get()),
          message);
      throw new IllegalStateException(message);
    } catch (IOException exception) {
      throw new DownstreamServiceException(message);
    } finally {
      sw.stop();
      if (logger.isInfoEnabled()) {
        logger.info(
            "{}, method=doSomething completed in {}ms",
            auditor.auditableLogMessage(ExecutionContextHolder.get()),
            sw.getTotalTimeMillis());
      }
    }
  }


    /**
   * Configures a GET request to  API server. Sets path, optional query parameters and
   * optional headers.
   *
   * @param builder URIBuilder builder with pre-built URI to which we can add query params if any.
   * @param queryParams optional query params
   * @param headers optional header values
   * @return HttpGet
   * @throws URISyntaxException exception
   */
  private HttpGet setupHttpGetRequest(
      final URIBuilder builder,
      final Optional<Map<String, String>> queryParams,
      final Optional<Map<String, String>> headers) throws URISyntaxException {

    queryParams.ifPresent(queryParamMap -> queryParamMap.forEach(builder::addParameter));
    URI uri = builder.build();
    HttpGet request = new HttpGet(uri);

    // set headers
    headers.ifPresent(headerMap -> headerMap.forEach(request::addHeader));

    return request;
  }

  /**
   * Configures a PUT request to  API server. Sets path, optional query parameters and
   * optional headers.
   *
   * @param builder URIBuilder builder with pre-built URI to which we can add query params if any.
   * @param queryParams optional query params
   * @param headers optional header values
   * @return HttpPut
   * @throws URISyntaxException exception
   */
  private HttpPut setupHttpPutRequest(
      final URIBuilder builder,
      final Optional<Map<String, String>> queryParams,
      final Optional<Map<String, String>> headers) throws URISyntaxException {

    queryParams.ifPresent(queryParamMap -> queryParamMap.forEach(builder::addParameter));
    URI uri = builder.build();
    HttpPut request = new HttpPut(uri);

    // set headers
    headers.ifPresent(headerMap -> headerMap.forEach(request::addHeader));

    return request;
  }

  /**
   * Configures a POST request to  API server. Sets path, optional query parameters and
   * optional headers.
   *
   * @param builder URIBuilder builder with pre-built URI to which we can add query params if any.
   * @param queryParams optional query params
   * @param headers optional header values
   * @return HttpPut
   * @throws URISyntaxException exception
   */
  private HttpPost setupHttpPostRequest(
      final URIBuilder builder,
      final Optional<Map<String, String>> queryParams,
      final Optional<Map<String, String>> headers) throws URISyntaxException {

    queryParams.ifPresent(queryParamMap -> queryParamMap.forEach(builder::addParameter));
    URI uri = builder.build();
    HttpPost request = new HttpPost(uri);

    // set headers
    headers.ifPresent(headerMap -> headerMap.forEach(request::addHeader));

    return request;
  }

  /**
   * Configures a DELETE request to  API server. Sets path, optional query parameters and
   * optional headers.
   *
   * @param builder URIBuilder builder with pre-built URI to which we can add query params if any.
   * @param queryParams optional query params
   * @param headers optional header values
   * @return HttpPut
   * @throws URISyntaxException exception
   */
  private HttpDelete setupHttpDeleteRequest(
      final URIBuilder builder,
      final Optional<Map<String, String>> queryParams,
      final Optional<Map<String, String>> headers) throws URISyntaxException {

    queryParams.ifPresent(queryParamMap -> queryParamMap.forEach(builder::addParameter));
    URI uri = builder.build();
    HttpDelete request = new HttpDelete(uri);

    // set headers
    headers.ifPresent(headerMap -> headerMap.forEach(request::addHeader));

    return request;
  }




}



================================================================================

