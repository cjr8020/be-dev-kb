
	@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
	
		Spring Security Topics

	@@@@@@@@@@@@@@@@@@@@@@@@@@@@@


================================================================================

	SecurityAutoConfiguration
	*************************

The default security configuration is implement in SecurityAutoConfiguration 
and in the classes imported from there

SpringBootWebSecurityConfiguration 
	for web security

AuthenticationManagerConfiguration 
	for authentication confiration which is also relevant in non-web apps.

To switch off the default web application security configuraiton completely,
you can add a bean with @EnableWebSecurity (this does not disable the authn manager
or Actuator's security).

To customize it, you normally use external properties and beans of type 
WebSecurityConfigurerAdapter.

	note: If you add @EnableWebSecurity and also disable Actuator security, you will get the default form-based login for the entire application unless you add a custom WebSecurityConfigurerAdapter.


================================================================================

	HttpSecurity.antMatcher(...) vs http.authorizeRequests().antMatchers(..)
	************************************************************************

http.antMatcher("/api/**")

	HttpSecurity.antMatcher()
		changes the default request matcher for the HttpSecurity instance to
		an AntPathRequestMatcdher from AnyRequestMatcher

http.authorizeRequests().antMatchers("/api/user/**", "/api/ticket/**", "/index")

	ExpressionUrlAuthorizationConfigurer.ExpressionInterceptUrlRegistry.antMatchers()
		is used for applying authz rules to a subset of endpoints associated
		with the current HttpSecurity instance

Example: 

here, basic auth is disabled for all endpoints matching "/api/**".
Additionally, endpoints matching "/api/user/**" and "/api/ticket/**" will require
the request's Authentication to contain ROLE_USER.

However, when user accesses "/index" they will be presented with basic auth
challenge.  Once authenticated, the user will be granted access regardless of
whether or not they have ROLE_USER.  This is because the .antMatcher("/api/**")
is  limiting the scope of the ENTIRE HttpSecurity instance to that specific
matcher.

	http
		.antMatcher("/api/**")
		.httpBasic()
			.diable()
		.authorizeRequests()
		.antMatchers("/api/user/**", "/api/ticket/**", "/index")
			.hasRole("ROLE_USER");



================================================================================


	Authorization
	*************

Method Security
---------------

In order to use Expression-Based Access Controls for method-level security
we need to 

@EnableWebSecurity
@EnableGlobalMethodSecurity(prePostEnabled = true)
	


	Expression-Based Access Control
	*******************************

allows complex boolean logic to be encapsulated in a single expression.

Common biult-in expressions
---------------------------

	hasRole([role])
		returns true if the current principal has the specified role.
		by default, if the supplied role does not start with 'ROLE_' that prefix
		will be added.
		This can be customized by modifying

			defaultRolePrefix on
			DefaultWebSecurityExpressionHandler

	hasAnyRole([role1,role2])
		returns true if the current principal has any of the supplied roles
		given a comma-separated list of strings.

		ROLE_ ...

	hasAuthority([authority])
		returns true if the current principal has the specified authority.

	hasAnyAuthority([authority1,authority2])


		NOTE: 
			a Role is a GrantedAuthority that starts with the prefix "ROLE_".
			hasAuthority('ROLE_ADMIN') means the same as 
			hasRole('ADMIN') b/c 'ROLE_' gets added automatically.

			in Spring 4
			@PreAuthorize("hasRole('XYZ')") == @PreAuthorize("hasAuthority('ROLE_XYZ')")



	principal
		allows direct access to the principal object representing the current
		user.

	authentication
		allows direct access to the curernt Authentication object obtained from
		SecurityContext

	permitAll 	always evaluates to true
	denyAll		always evaluates to false

	isAnonymous()
		true if current principal is anonymous

	isRememberMe()
		true if current principal is remember-me user

	isAuthenticated()
		true .. if not anonymous

	isFullyAuthenticated()
		true .. if the user is not anonymous or a remember-me user

	hasPermission(Object target, Object permission)
		true if the user has access to provided target for the given permission

			hasPermission(domainObject, 'read')

	hasPermission(Object targetId, String targetType, Object permission)

			hasPermission(1, 'com.example.domain.Message', 'read')


@Pre and @Post Annotations
--------------------------

	@PreAuthorize

		most useful decides whether a method can actually be invoked or not.
		e.g.:

			@PreAuthorize("hasRole('USER')")
			public void create(Contact contact);



	@PostAuthorize


================================================================================

	AuthenticationEntryPoint
	************************

https://docs.spring.io/spring-security/site/docs/3.0.x/reference/technical-overview.html

	Authentication in a Web Application


Consider a typical web application's authentication process:

	1. You visit the home page, and click on a link.

	2. A request goes to the server, and the server decides that you've asked for a protected resource.

	3. As you're not presently authenticated, the server sends back a response indicating that you must authenticate. The response will either be an HTTP response code, or a redirect to a particular web page.

	4. Depending on the authentication mechanism, your browser will either redirect to the specific web page so that you can fill out the form, or the browser will somehow retrieve your identity (via a BASIC authentication dialogue box, a cookie, a X.509 certificate etc.).

	5. The browser will send back a response to the server. This will either be an HTTP POST containing the contents of the form that you filled out, or an HTTP header containing your authentication details.

	6. Next the server will decide whether or not the presented credentials are valid. If they're valid, the next step will happen. If they're invalid, usually your browser will be asked to try again (so you return to step two above).

	7. The original request that you made to cause the authentication process will be retried. Hopefully you've authenticated with sufficient granted authorities to access the protected resource. If you have sufficient access, the request will be successful. Otherwise, you'll receive back an HTTP error code 403, which means "forbidden".

Spring Security has distinct classes responsible for most of the steps described above. The main participants (in the order that they are used) are the ExceptionTranslationFilter, an AuthenticationEntryPoint and an “authentication mechanism”, which is responsible for calling the AuthenticationManager which we saw in the previous section.

	ExceptionTranslationFilter
	--------------------------
ExceptionTranslationFilter is a Spring Security filter that has responsibility for detecting any Spring Security exceptions that are thrown. Such exceptions will generally be thrown by an AbstractSecurityInterceptor, which is the main provider of authorization services.


	AuthenticationEntryPoint
	------------------------

The AuthenticationEntryPoint is responsible for step three in the above list. 

As you can imagine, each web application will have a default authentication strategy (well, this can be configured like nearly everything else in Spring Security, but let's keep it simple for now). 

Each major authentication system will have its own AuthenticationEntryPoint implementation, which typically performs one of the actions described in step 3.


	Spring Security Entry Point

http://sunilkumarpblog.blogspot.com/2016/01/spring-security-entry-point-and-role.html

1. when user logs in by providing credentials, spring filter will eval
user creds with the help of UserDetails service provider.

2. If user is authn successfully, then spring filter will invoke success handler.
Otherwise failure handler.

3. If success, then success handler will redirect to page based on rules.
   If failure, then failure handler will redirect to access denied page.

4. If user not logged in, Spring Security handles request with the concept of 
   an Entry Point - for any request, the application entry point will redirect
   to the login page.





https://docs.spring.io/spring-security/site/docs/3.0.x/reference/core-web-filters.html

The AuthenticationEntryPoint will be called if the user requests a secure HTTP resource but they are not authenticated. An appropriate AuthenticationException or AccessDeniedException will be thrown by a security interceptor further down the call stack, triggering the commence method on the entry point. 

This does the job of presenting the appropriate response to the user so that authentication can begin. The one we've used here is LoginUrlAuthenticationEntryPoint, which redirects the request to a different URL (typically a login page). The actual implementation used will depend on the authentication mechanism you want to be used in your application.
	

================================================================================

	Multiple Entry Points
	*********************

http://www.baeldung.com/spring-security-multiple-entry-points

SOURCE: https://github.com/eugenp/tutorials/blob/master/spring-security-mvc-boot/src/main/java/org/baeldung/multipleentrypoints/MultipleEntryPointsSecurityConfig.java



Spring Security support the definition of multiple HTTP elements in configurations.

When using Java configuration, the way to define multiple security realms is to have multiple @Configuration classes that extend the WebSecurityConfigurerAdapter base class – each with its own security configuration. 

These classes can be static and placed inside the main config.

The main motivation for having multiple entry points in one application is if there are different types of users that can access different portions of the application.

Let’s define a configuration with three entry points, each with different permissions and authentication modes:

* one for administrative users using HTTP Basic Authentication
* one for regular users that use form authentication
* and one for guest users that do not require authentication

Admin user entry point:

	The entry point defined for administrative users secures URLs of the form /admin/** to only allow users with a role of ADMIN and requires HTTP Basic Authentication with an entry point of type BasicAuthenticationEntryPoint that is set using the authenticationEntryPoint() method:

		@Configuration
		@Order(1)
		public static class App1ConfigurationAdapter extends WebSecurityConfigurerAdapter {
		 
		    @Override
		    protected void configure(HttpSecurity http) throws Exception {
		        http.antMatcher("/admin/**")
		            .authorizeRequests().anyRequest().hasRole("ADMIN")
		            .and().httpBasic().authenticationEntryPoint(authenticationEntryPoint());
		    }
		 
		    @Bean
		    public AuthenticationEntryPoint authenticationEntryPoint(){
		        BasicAuthenticationEntryPoint entryPoint = 
		          new BasicAuthenticationEntryPoint();
		        entryPoint.setRealmName("admin realm");
		        return entryPoint;
		    }
		}

The @Order annotation on each static class indicates the order in which the configurations will be considered to find one that matches the requested URL. The order value for each class must be unique.



User Entry Point

	Configuration for URLs of the form /user/** that can be accessed by regular users with a USER role using form authentication:

		@Configuration
		@Order(2)
		public static class App2ConfigurationAdapter extends WebSecurityConfigurerAdapter {
		 
		    protected void configure(HttpSecurity http) throws Exception {
		        http.antMatcher("/user/**")
		            .authorizeRequests().anyRequest().hasRole("USER")
		            .and()
		            // formLogin configuration
		            .and()
		            .exceptionHandling()
		            .defaultAuthenticationEntryPointFor(
		              loginUrlauthenticationEntryPointWithWarning(),
		              new AntPathRequestMatcher("/user/private/**"))
		            .defaultAuthenticationEntryPointFor(
		              loginUrlauthenticationEntryPoint(), 
		              new AntPathRequestMatcher("/user/general/**"));
		    }
		}

	As we can see, another way of defining entry points, besides the authenticationEntryPoint() method, is to use the defaultAuthenticationEntryPointFor() method. This can define multiple entry points that match different conditions based on a RequestMatcher object.

	The RequestMatcher interface has implementations based on different types of conditions, such as matching path, media type or regexp. In our example, we have used the AntPathRequestMatch to set two different entry points for URLs of the forms /user/private/** and /user/general/**.

	Next, we need to define the entry points beans in the same static configuration class:

		@Bean
		public AuthenticationEntryPoint loginUrlauthenticationEntryPoint(){
		    return new LoginUrlAuthenticationEntryPoint("/userLogin");
		}
		         
		@Bean
		public AuthenticationEntryPoint loginUrlauthenticationEntryPointWithWarning(){
		    return new LoginUrlAuthenticationEntryPoint("/userLoginWithWarning");
		}

	The main point here is how to set up these multiple entry points – not necessarily the implementation details of each one.

	In this case, the entry points are both of type LoginUrlAuthenticationEntryPoint, and use different login page URL: /userLogin for a simple login page and /userLoginWithWarning for a login page that also displays a warning when attempting to access the /user/ private URLs.

	This configuration will also require defining the /userLogin and /userLoginWithWarning MVC mappings and two pages with a standard login form.

	For the form authentication, it’s very important to remember that any URL necessary for the configuration, such as the login processing URL also needs to follow the /user/** format or be otherwise configured to be accessible.

	Both of the above configurations will redirect to a /403 URL if a user without the appropriate role attempts to access a protected URL.

	Be careful to use unique names for the beans even if they are in different static classes, otherwise one will override the other.


Guest Entry Point

	Finally, let’s define the third configuration for URLs of the form /guest/** that will allow all types of users, including unauthenticated ones:

		@Configuration
		@Order(3)
		public static class App3ConfigurationAdapter extends WebSecurityConfigurerAdapter {
		 
		    protected void configure(HttpSecurity http) throws Exception {
		        http.antMatcher("/guest/**").authorizeRequests().anyRequest().permitAll();
		    }
		}


Example Source:
--------------------------------------------------------------------------------

package org.baeldung.multipleentrypoints;

import org.springframework.context.annotation.Bean;
import org.springframework.context.annotation.Configuration;
import org.springframework.core.annotation.Order;
import org.springframework.security.config.annotation.web.builders.HttpSecurity;
import org.springframework.security.config.annotation.web.configuration.EnableWebSecurity;
import org.springframework.security.config.annotation.web.configuration.WebSecurityConfigurerAdapter;
import org.springframework.security.core.userdetails.User;
import org.springframework.security.core.userdetails.UserDetailsService;
import org.springframework.security.provisioning.InMemoryUserDetailsManager;
import org.springframework.security.web.AuthenticationEntryPoint;
import org.springframework.security.web.authentication.LoginUrlAuthenticationEntryPoint;
import org.springframework.security.web.authentication.www.BasicAuthenticationEntryPoint;
import org.springframework.security.web.util.matcher.AntPathRequestMatcher;

@Configuration
@EnableWebSecurity
public class MultipleEntryPointsSecurityConfig {

    @Bean
    public UserDetailsService userDetailsService() throws Exception {
        InMemoryUserDetailsManager manager = new InMemoryUserDetailsManager();
        manager.createUser(User.withUsername("user").password("userPass").roles("USER").build());
        manager.createUser(User.withUsername("admin").password("adminPass").roles("ADMIN").build());
        return manager;
    }

    @Configuration
    @Order(1)
    public static class App1ConfigurationAdapter extends WebSecurityConfigurerAdapter {

        @Override
        protected void configure(HttpSecurity http) throws Exception {
            //@formatter:off
            http.antMatcher("/admin/**")
                .authorizeRequests().anyRequest().hasRole("ADMIN")
                .and().httpBasic().authenticationEntryPoint(authenticationEntryPoint())    
                .and().exceptionHandling().accessDeniedPage("/403");
            //@formatter:on
        }
        
        @Bean
        public AuthenticationEntryPoint authenticationEntryPoint(){
            BasicAuthenticationEntryPoint entryPoint = new  BasicAuthenticationEntryPoint();
            entryPoint.setRealmName("admin realm");
            return entryPoint;
        }
    }

    @Configuration
    @Order(2)
    public static class App2ConfigurationAdapter extends WebSecurityConfigurerAdapter {

        protected void configure(HttpSecurity http) throws Exception {
            
            //@formatter:off
            http.antMatcher("/user/**")
                .authorizeRequests().anyRequest().hasRole("USER")              
                .and().formLogin().loginProcessingUrl("/user/login")
                .failureUrl("/userLogin?error=loginError").defaultSuccessUrl("/user/myUserPage")
                .and().logout().logoutUrl("/user/logout").logoutSuccessUrl("/multipleHttpLinks")
                .deleteCookies("JSESSIONID")
                .and().exceptionHandling()
                .defaultAuthenticationEntryPointFor(loginUrlauthenticationEntryPointWithWarning(),  new AntPathRequestMatcher("/user/private/**"))
                .defaultAuthenticationEntryPointFor(loginUrlauthenticationEntryPoint(), new AntPathRequestMatcher("/user/general/**"))
                .accessDeniedPage("/403")
                .and().csrf().disable();
            //@formatter:on
        }
        
        @Bean
        public AuthenticationEntryPoint loginUrlauthenticationEntryPoint(){
            return new LoginUrlAuthenticationEntryPoint("/userLogin");
        }
        
        @Bean
        public AuthenticationEntryPoint loginUrlauthenticationEntryPointWithWarning(){
            return new LoginUrlAuthenticationEntryPoint("/userLoginWithWarning");
        }
    }

    @Configuration
    @Order(3)
    public static class App3ConfigurationAdapter extends WebSecurityConfigurerAdapter {

        protected void configure(HttpSecurity http) throws Exception {
            http.antMatcher("/guest/**").authorizeRequests().anyRequest().permitAll();
        }
    }

}		

================================================================================

	Spring Expression Language (SpEL)
	*********************************

http://www.baeldung.com/spring-expression-language	

supports querying and manipulating an object graph at runtime.
it can be used with XML or annotation-based Spring configurations.

	Arithmetic	+, -, *, /, %, ^, div, mod
	Relational	<, >, ==, !=, <=, >=, lt, gt, eq, ne, le, ge
	Logical	and, or, not, &&, ||, !
	Conditional	?:
	Regex	matches

Examples

Arithmetic Operators
---------------------

	@Value("#{19 + 1}") // Will inject 20
	private double add; 
	 
	@Value("#{'String1 ' + 'string2'}") // Will inject "String1 string2"
	private String addString; 


Relational and Logical Operators
--------------------------------

	@Value("#{1 == 1}") // Will inject true
	private boolean equal;
	 
	@Value("#{1 eq 1}") // Will inject true
	private boolean equalAlphabetic;
	 
	@Value("#{1 != 1}") // Will inject false
	private boolean notEqual;


Logical Operators
----------------

	@Value("#{250 > 200 && 200 < 4000}") // Will inject true
	private boolean and; 
	 
	@Value("#{250 > 200 and 200 < 4000}") // Will inject true
	private boolean andAlphabetic;
it can be used with XML or annotation-based Spring configurations.

	Arithmetic	+, -, *, /, %, ^, div, mod
	Relational	<, >, ==, !=, <=, >=, lt, gt, eq, ne, le, ge
	Logical	and, or, not, &&, ||, !
	Conditional	?:
	Regex	matches

Examples

Arithmetic Operators
---------------------

	@Value("#{19 + 1}") // Will inject 20
	private double add; 
	 
	@Value("#{'String1 ' + 'string2'}") // Will inject "String1 string2"
	private String addString; 


Relational and Logical Operators
--------------------------------

	@Value("#{1 == 1}") // Will inject true
	private boolean equal;
	 
	@Value("#{1 eq 1}") // Will inject true
	private boolean equalAlphabetic;
	 
	@Value("#{1 != 1}") // Will inject false
	private boolean notEqual;


Logical Operators
----------------

	@Value("#{250 > 200 && 200 < 4000}") // Will inject true
	private boolean and; 
	 
	@Value("#{250 > 200 and 200 < 4000}") // Will inject true
	private boolean andAlphabetic;

================================================================================

	Spring password encoding
	************************

BCryptPasswordEncoder
---------------------

	Implementation of PasswordEncoder that uses the BCrypt strong hashing function. 
	
	Clients can optionally supply a "strength" (a.k.a. log rounds in BCrypt) and 
	a SecureRandom instance. The larger the strength parameter the more work will have to be done (exponentially) to hash the passwords. 

	Strength: number of rounds

		(default) 10
		between 4 and 31

	BCrypt will internally generate a random salt.

	BCrypt generates a String of length 60.

	Constructors:

		BCryptPasswordEncoder() 
		BCryptPasswordEncoder(int strength) 
		BCryptPasswordEncoder(int strength, SecureRandom random) 	


Older Implementations:

	MD5PasswordEncoder and ShaPasswordEncoder use weaker algorithms and are now
	deprecated.

ShaPasswordEncoder
------------------

	requries a client to pass in a salt value when encoding.
	BCrypt will internally generate a random salt instead.

MD5PasswordEncorder
-------------------


================================================================================

	Multiple HttpSecurity
	*********************

https://docs.spring.io/spring-security/site/docs/current/reference/html/jc.html#multiple-httpsecurity

We can configure multiple HttpSecurity instances just as we can have multiple <http> blocks. The key is to extend the WebSecurityConfigurationAdapter multiple times. 

For example, the following is an example of having a different configuration for 
URL’s that start with /api/.

	@EnableWebSecurity
	public class MultiHttpSecurityConfig {

		/**
		 * (1) Configure Authentication as normal
		 */
		@Bean                                                             1
		public UserDetailsService userDetailsService() throws Exception {
			// ensure the passwords are encoded properly
			UserBuilder users = User.withDefaultPasswordEncoder();
			InMemoryUserDetailsManager manager = new InMemoryUserDetailsManager();
			manager.createUser(users.username("user").password("password").roles("USER").build());
			manager.createUser(users.username("admin").password("password").roles("USER","ADMIN").build());
			return manager;
		}


		/**
		 * (2) create an instance of WebSecurityConfigurerAdapter that contains
		 * @Order to specify which WebSecurityConfigurerAdapter should be 
		 * considered first.
		 * 
		 * (3) The http.antMatcher states that this HttpSecurity will only be
		 * applicable to URLs that start with "/api/**"
		 */
		@Configuration
		@Order(1)                                                        2
		public static class ApiWebSecurityConfigurationAdapter extends WebSecurityConfigurerAdapter {
			protected void configure(HttpSecurity http) throws Exception {
				http
					.antMatcher("/api/**")                               3
					.authorizeRequests()
						.anyRequest().hasRole("ADMIN")
						.and()
					.httpBasic();
			}
		}

		/**
		 * Create another instance of WebSecurityConfigurerAdapter.
		 * If the URL doesn't start with /api/, this configuration will be used.
		 * This configuration is considered after ApiWebSecurityConfigurationAdapter
		 * since its order is after "1" (i.e. no @Order defaults to last)
		 */
		@Configuration                                                   4
		public static class FormLoginWebSecurityConfigurerAdapter extends WebSecurityConfigurerAdapter {

			@Override
			protected void configure(HttpSecurity http) throws Exception {
				http
					.authorizeRequests()
						.anyRequest().authenticated()
						.and()
					.formLogin();
			}
		}
	}


================================================================================

	Debug Spring Security Filter Chain
	**********************************

1. logging

logging:
  file: logs/claims-intake-api-service.log
  pattern:
    console: "%clr(%d{yyyy-MM-dd HH:mm:ss.SSS}){faint} %clr(%5p) %clr(18971){magenta} %clr(---){faint} %clr([%15.15t]){faint} %clr(%-40.40logger{39}){cyan} %clr(:){faint} %m%n%wEx"
    file: "%d %-5level [%thread] %logger : %msg%n"
  level:
    org.springframework.web: DEBUG
    org.springframework.security: DEBUG

2. security debug

@EnableWebSecurity(debug = true)


************************************************************

Request received for GET '/blah':

org.apache.catalina.connector.RequestFacade@43084931

servletPath:/draft-claims
pathInfo:null
headers: 
content-type: application/json
cache-control: no-cache
postman-token: da6591f2-addc-4e85-9d3e-3147de9dff52
authorization: Basic YXBpdXNlcjphcGlwYdfasdfd29yZA==
user-agent: PostmanRuntime/7.1.1
accept: */*
host: localhost:9013
accept-encoding: gzip, deflate
connection: keep-alive


Security filter chain: [
  WebAsyncManagerIntegrationFilter
  SecurityContextPersistenceFilter
  HeaderWriterFilter
  LogoutFilter
  OAuth2AuthenticationProcessingFilter
  RequestCacheAwareFilter
  SecurityContextHolderAwareRequestFilter
  AnonymousAuthenticationFilter
  SessionManagementFilter
  ExceptionTranslationFilter
  FilterSecurityInterceptor
]


************************************************************

note: no BasicAuthenticationFilter in the above chain ..

================================================================================

	Spring Security with Dropwizard
	*******************************

https://stackoverflow.com/questions/22980509/integrating-dropwizard-with-spring-security	

Spring Security is really just a glorified ServletFilter that you can add to the Dropwizard application.

DW 0.7.0 and above:

FilterRegistration.Dynamic filterRegistration = environment.servlets().addFilter("springSecurityFilterChain", DelegatingFilterProxy.class);
filterRegistration.addMappingForUrlPatterns(EnumSet.allOf(DispatcherType.class), false, "/*");

================================================================================