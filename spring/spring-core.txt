	@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
	
		Spring Core Topics

	@@@@@@@@@@@@@@@@@@@@@@@@@@@@@


================================================================================

	@ComponentScan with basePackageclasses
	**************************************

Type-safe alternative to basePackages() for specifying the packages to
scan for annotated components.  The package of each class specified will be scanned.
Consider creating a special no-op marker class or interface in each package that serves no purpose other than being referenced by this attribute.

	By type-safe, you can't make any mistakes with the String value of the name of the package. If you specify an incorrect class, it will fail at compile time.

E.g. 
@ComponentScan(basePackageClasses = Controllers.class)

When you specify basePackageClasses, Spring will scan the package (and subpackages) of the classes you specify. This is a nice trick with no-op classes/interfaces like Controllers, Services, etc. Put all your controllers in one package containing the Controllers class and specify your Controllers class in the basePackageClasses. Spring will pick them all up.



================================================================================

	Scoped Proxy
	************


http://sanseeni.blogspot.com/2011/12/understanding-scoped-proxy-in-spring.html

Let say there are two classes, namely SingletonBean and PrototypeBean class, where prototype bean reference is kept inside the singleton bean. And as the name suggests, SingletonBean is specified with "singleton" scope and "prototype" scope for PrototypeBean. 

Now if we access the singleton bean using the application context, it will create single instance all times. However if we access the prototype bean reference using the singleton bean reference it will also show single instance all times because it has been wrapped inside the singleton bean, which is an expected behaviour under singleton pattern scenario. 

But we specified the prototype scope in PrototypeBean and if we wanted to return a new PrototypeBean object every time when we access using the singleton reference(getPrototypeBean()),..

then we need to specify the prototype bean additionally using

	@Scope(value="prototype", proxyMode=ScopedProxyMode.TARGET_CLASS) 

as annotation.

Example:

SingletonBean
----------------------

@Component
@Scope(value="singleton")
public class SingletonBean {

	@Autowired
	private PrototypeBean prototypeBean;

	/**
	 * 
	 */
	public SingletonBean() {
	}

	public PrototypeBean getPrototypeBean() { return prototypeBean;	}

	public void setPrototypeBean(PrototypeBean prototypeBean) {
		this.prototypeBean = prototypeBean;
	}

}

PrototypeBean
-------------------------

@Component
@Scope(value="prototype", proxyMode=ScopedProxyMode.TARGET_CLASS)
public class PrototypeBean {

	/**
	 * 
	 */
	public PrototypeBean() {}

}

When we test these beans after wiring them using component-scan, we
find below results:

SingletonBean singletonBean = (SingletonBean)container.getBean("singletonBean");
System.out.println("singleton instance :"+singletonBean); //container.bean.SingletonBean@2200d5
System.out.println("prototype instance :"+singletonBean.getPrototypeBean()); //container.bean.PrototypeBean@df1832

singletonBean = (SingletonBean)container.getBean("singletonBean");
System.out.println("singleton instance :"+singletonBean); //container.bean.SingletonBean@2200d5
System.out.println("prototype instance :"+singletonBean.getPrototypeBean());//container.bean.PrototypeBean@ad8659


================================================================================

	Create a request scoped bean at runtime
	****************************************

UserDetails POJO needs to be created at runtime per request ...

	public class UserDetails {

	    private String name;

	    // getter / setter ... 

	    public UserDetails(String name) {
	        this.name = name;
	    }
	}

Here is the factory class .. 


	@Configuration
	public class UserFactory {

	    @Bean
	    @Scope(value = "request", proxyMode = ScopedProxyMode.TARGET_CLASS) 
	    public UserDetails createUserDetails() {
	        // this method should be called on every request
	        String name = SecurityContextHolder.getContext()
	                        .getAuthentication().getPrincipal(); // get some user details, just an example (I am aware of Principal)

	        // construct a complex user details object here
	        return new UserDetails(name);
	    }
	}

... and this is the class where the UserDetails instance should be injected:


	@RestController
	@RequestMapping(value = "/api/something")
	public class MyResource {

		/* 
		 * UserDetails here is a scoped proxy
		 */ 
    	@Autowired
    	private UserDetails userDetails;	

	    @RequestMapping(method = RequestMethod.GET)
	    @ResponseBody
	    public List<String> getSomething() {

	        // the userdetails should be injected here per request
	        // do something
	    }
	}




================================================================================

	ConfigurationProperties
	***********************
https://docs.spring.io/spring-boot/docs/current/reference/htmlsingle/#configuration-metadata-nested-properties

server
  name: blah
  host:
    ip: 127.0.0.1
    port: 8080


@ConfigurationProperties(prefix="server")
public class ServerProperties {

    private String name;

    private Host host;

    // ... getter and setters

    private static class Host {

        private String ip;

        private int port;

        // ... getter and setters

    }

}

If you don't want to use inner classes then you can annotate the fields with @NestedConfigurationProperty.

@ConfigurationProperties(prefix="server")
public class DatabaseProperties {

    @NestedConfigurationProperty
    private Host host; // Host is defined somewhere else

}

This will indicated that Host is defined somewhere else but should be treated 
as if it were nested.



================================================================================

	Constructor Inejection
	**********************

https://spring.io/blog/2016/03/04/core-container-refinements-in-spring-framework-4-3	

configuration creating beans	

	@Configuration
	public class Config {
	 
	    @Bean
	    public Engine engine() {
	        return new Engine("v8", 5);
	    }
	 
	    @Bean
	    public Transmission transmission() {
	        return new Transmission("sliding");
	    }
	}

component requiring beans

	@Component
	public class Car {
	 
	    @Autowired
	    public Car(Engine engine, Transmission transmission) {
	        this.engine = engine;
	        this.transmission = transmission;
	    }
	}

Spring will encounter our Car class while doing a package scan and will initialize its instance by calling the @Autowired annotated constructor.

Instances of Engine and Transmission will be obtained by calling @Bean annotated methods of the Config class.



	As of Spring 4.3, classes with a single constructor can omit the @Autowired annotation.
	On top of that, also starting with 4.3, constructor-based injection can be leveraged in @Configuration annotated classes. 

	https://spring.io/blog/2016/03/04/core-container-refinements-in-spring-framework-4-3


Finally, obtain car from ApplicationContext:	

	ApplicationContext context = new AnnotationConfigApplicationContext(Config.class);
	Car car = context.getBean(Car.class);


================================================================================

	@Component @Service @Controller @Repository
	*******************************************

| Annotation | Meaning                                             |
+------------+-----------------------------------------------------+
| @Component | generic stereotype for any Spring-managed component |
| @Repository| stereotype for persistence layer                    |
| @Service   | stereotype for service layer                        |
| @Controller| stereotype for presentation layer (spring-mvc)      |


@Component 
 is a generic stereotype for any Spring-managed component.
 is equivalent to

	<bean> 

@Repository
@Service
@Controller
 a specializations of @Component for more specific use cases
 in persistence, service and presentation layers.

Therefore, you can annotate your component classes with @Component, but by annotating them with @Repository, @Service, or @Controller instead, your classes are more properly suited for processing by tools or associating with aspects. For example, these stereotype annotations make ideal targets for pointcuts.

Thus, if you are choosing between using @Component or @Service for your service layer, @Service is clearly the better choice. Similarly, as stated above, @Repository is already supported as a marker for automatic exception translation in your persistence layer.

================================================================================

	@ComponentScan
	**************
An equivalent for Spring XML's <context:component-scan/> is provided with the @ComponentScan annotation.

Spring's @Service and @Repository stereotype annotations are specializations of
@Component and are therefore candidates for component scanning.

// search the com.company package for @Component classes   
	@Configuration
	@ComponentScan("com.company") 
	public class Config {
	}

   
 "basePackageClasses"
 --------------------------------

 The basePackageClasses attribute is the type-safe alternative to basePackages() in order to specify the packages to scan for the annotated components. The package of each specified class will be scanned.

 This will ensure that even when the package is renamed or moved, the component scan would work as expected.


 @ComponentScan(basePackageClasses = ApplicationController.class)     
 public class SomeApplication {
 	// ... 
 }

================================================================================

	BeanDefinitionRegistryPostProcessor
	***********************************
	BeanDefinition
	**************
	BeanDefinitionRegistry
	**********************

If client code needs to register objects which are not managed  by Spring
container, then we will need to work with an instance of BeanDefinition.

A Spring application can register a BeanDefinition by using the following
method of BeanDefinitionRegistry:

	 void registerBeanDefinition(String beanName, BeanDefinition beanDefinition)

BeanDefinition 
	describes a bean instance
	has setter methods which can be used to programmatically set the 
	Spring specific characteristics to a bean, e.g.
		BeanDefintition #setScope(String scope)


BeanDefinitionRegistryPostProcessor
-----------------------------------------------------
http://www.logicbig.com/tutorials/spring-framework/spring-core/bean-definition/

@see note on PriorityOrdered


It allows for the registration of bean definitions. It's method postProcessBeanDefinitionRegistry is called before BeanFactoryPostProcessor#postProcessBeanFactory. 
This interface is more focused on the BeanDefinition registration rather than general purpose BeanFactoryPostProcessor.

	When we a have Spring managed application, we want to let Spring manage all of our beans. Beside the regular way of creating beans with known solutions like Annotated beans, Java Configuration and XML Configuration, there is also a way in which we can create our own BeanDefinition.

	With a BeanDefinitionRegistryPostProcessor it is possible to create a specific post processor which can add BeanDefinitions to the BeanDefinitionRegistry.
	It differs from the BeanPostProcessor, which only has hooks for Bean Initialization (construction of your POJO), where the BeanDefinitionRegistryPostProcessor has a hook on the BeanDefinitionRegistry. This gives us the ability to define our own BeanDefinition.

1. first we create a BeanDefinitionRegistryPostProcessor implementation.

2. we implement the required method postProcessBeanDefinitionRegistry(..)

3. The defined BeanDefinition s will be picked up by the ApplicationContext.


@Component
public class LogicServiceRegistryPostProcessor 
        implements BeanDefinitionRegistryPostProcessor {
 
    @Override
    public void postProcessBeanDefinitionRegistry(BeanDefinitionRegistry registry)
            throws BeansException {
 
        RootBeanDefinition beanDefinition = 
                new RootBeanDefinition(MyServiceImpl.class); //The service implementation
        serviceDefinition.setTargetType(MyService.class); //The service interface
        serviceDefinition.setRole(BeanDefinition.ROLE_APPLICATION);
        registry.registerBeanDefinition("myBeanName", beanDefinition );
    }
}



Using BeanFactoryPostProcessor
---------------------------------------------------

BeanFactoryPostProcessor allows client code to customize bean definitions.

BeanFactoryPostProcessor.postProcessBeanFactory() is called by Spring
startup process just after all bean definitions have been loaded, but no
beans have been initialized yet.

	@Configuration
	public class MyConfig {
	  @Bean
	  MyConfigBean myConfigBean () {
	      return new MyConfigBean();
	  }
	}

	public class MyConfigBean implements BeanFactoryPostProcessor {

	  @Override
	  public void postProcessBeanFactory (
	            ConfigurableListableBeanFactory beanFactory)
	            throws BeansException {

	      GenericBeanDefinition bd = new GenericBeanDefinition();
	      bd.setBeanClass(MyBean.class);
	      bd.getPropertyValues().add("strProp", "my string property");

	      ((DefaultListableBeanFactory) beanFactory)
	                .registerBeanDefinition("myBeanName", bd);
	  }
	}

	public class MyBean {
	  private String strProp;

	  public void setStrProp (String strProp) {
	      this.strProp = strProp;
	  }

	  public void doSomething () {
	      System.out.println("from MyBean:  " + strProp);
	  }
	}

	public class BeanFactoryPostProcessorExample {

	  public static void main (String[] args) {
	      AnnotationConfigApplicationContext context =
	                new AnnotationConfigApplicationContext(MyConfig.class);
	      MyBean bean = context.getBean(MyBean.class);
	      bean.doSomething();
	  }
	}

Output
	from MyBean:  my string property
	WARNING: @Bean method MyConfig.myConfigBean is non-static and returns an object assignable to Spring's BeanFactoryPostPro

================================================================================

	Configuration as a Service
	**************************

https://tuhrig.de/why-using-springs-value-annotation-is-bad/

Usually

	@Service
	public class MyService {
	 
	    @Value("${my.config.property.key}")
	    private String someConfigValue;
	    
	    //...
	}	

whenever you need some property, you will inject it. You will inject it in services, controllers and components and you will properly inject the same property in different classes.

this means nothing else than scattering your configuration about your whole application. Every class can pick a couple of properties to use. You will have no idea or control which class is using which properties. You will end-up with doing a full text search on your project to find out where a single key is used. You will have a lot of fun if you want to rename one of those keys or when you need to set each and every property for each and every class in your unit tests.

	Configuration as a Service
	-------------------------

Instead of this, configuration should be an encapsulated service of your application such as any other functionality, too. You encapsulate persistence in DAOs, you encapsulate REST services in controllers and you encapsulate security in authenticators. So why not encapsulating configuration?


	@Service
	public class ConfigurationService {
	 
	    @Value("${my.config.property.key}")
	    private String someConfigValue;
	 
	    // getters, setters, sanity checks and so on...
	}
	 
	@Service
	public class MyService {
	 
	    @Autowire
	    private ConfigurationService configurationService ;
	    
	    //...
	}


================================================================================