
	@@@@@@@@@@@@@@@@@@@

		SpringBoot

	@@@@@@@@@@@@@@@@@@@


================================================================================

	SpringBoot Security
	*******************

If Spring Security is on the classpath then web applications will be secure by default with ‘basic’ authentication on all HTTP endpoints. 

To add method-level security to a web application you can also add @EnableGlobalMethodSecurity with your desired settings.


	Default SpringBoot Security
	***************************

The default AuthenticationManager has a single user (‘user’ username and random password, printed at INFO level when the application starts up):

	Using default security password: 78fa095d-3f4c-48b1-ad50-e24c31d5cf35



	Override Default SpringBoot Security
	************************************

You can provide a WebSecurityconfigurerAdapter with 

  @Override
  public void configure(AuthenticationManagerBuilder auth) throws Exception {
  	. . .
  }

  @Override
  public void configure(HttpSecurity http) throws Exception {
  	. . .
  }

doesn't matter! - Default SrpingBoot Security will still be in effect.

You need to annotate your WebSecurityConfigurerAdapter with @EnableWebSecurity


	@Order(SecurityProperties.ACCESS_OVERRIDE_ORDER)
	@Configuration
	@EnableWebSecurity
	public class ApplicationEndpointSecurity extends WebSecurityConfigurerAdapter {

	  @Override
	  public void configure(AuthenticationManagerBuilder auth) throws Exception {
	  	. . .
	  }

	  @Override
	  public void configure(HttpSecurity http) throws Exception {
	  	. . .
	  }

	}


and now those overrides will take effect.


NOTE: on ManagementServerProperties
		-----------------------------

If you provide a @Configuration with 

	@Order(ManagementServerProperties.ACCESS_OVERRIDE_ORDER)

it WILL override the Default SpringBoot Security, but for the Management
endpoint ONLY!!!


	/**
	 * Management Endpoint Configuration.
	 */
	@Configuration
	@Order(ManagementServerProperties.ACCESS_OVERRIDE_ORDER)
	public class ManagementEndpointConfiguration extends WebSecurityConfigurerAdapter {

	  private static final Logger log = LoggerFactory.getLogger(ManagementEndpointConfiguration.class);

	  /* management.security.user.name */
	  @Value("${management.security.user.name}")
	  private String name;

	  /* management.security.user.password */
	  @Value("${management.security.user.password}")
	  @NestedConfigurationProperty
	  private String password;

	  @Override
	  protected void configure(AuthenticationManagerBuilder auth) throws Exception {

	    auth
	        .inMemoryAuthentication()
	        .withUser(name)
	        .password(password)
	        .roles("ACTUATOR");
	  }

	  @Override
	  protected void configure(HttpSecurity http) throws Exception {
	    http
	        .authorizeRequests()
	        .anyRequest()
	        .authenticated()
	        .and()
	        .httpBasic();
	  }
	}







================================================================================

	Formatting Java Time with SpringBoot using Jackson
	**************************************************

https://touk.pl/blog/2016/02/12/formatting-java-time-with-spring-boot-using-json/

add 

    <dependency>
      <groupId>com.fasterxml.jackson.datatype</groupId>
      <artifactId>jackson-datatype-jsr310</artifactId>
      <version>2.9.2</version>
    </dependency>

appliation.yml:

	spring.jackson.serialization.write_dates_as_timestamps: false


Custom formatting

	@JsonFormat(pattern = "dd::MM::yyyy")
	private final LocalDate localDate;

	@JsonFormat(pattern = "KK:mm a")
	private final LocalTime localTime;

now you get

{  
   "version":2,
   "localDate":"01::01::2016",
   "localTime":"10:24 AM",
   "localDateTime":"2016-01-01T10:24",
   "zonedDateTime":"2016-01-01T10:24:00+01:00"
}

================================================================================

	Jetty instead of Tomcat
	***********************

		<dependency>
			<groupId>org.springframework.boot</groupId>
			<artifactId>spring-boot-starter-web</artifactId>
			<exclusions>
				<exclusion>
					<groupId>org.springframework.boot</groupId>
					<artifactId>spring-boot-starter-tomcat</artifactId>
				</exclusion>
			</exclusions>
		</dependency>

		<dependency>
			<groupId>org.springframework.boot</groupId>
			<artifactId>spring-boot-starter-jetty</artifactId>
		</dependency>


================================================================================

	Typesafe configuration properties
	*********************************

https://docs.spring.io/spring-boot/docs/1.2.0.RELEASE/reference/htmlsingle/#boot-features-external-config-typesafe-configuration-properties


	Using the @Value("${property}") annotation to inject configuration properties can sometimes be cumbersome, especially if you are working with multiple properties or your data is hierarchical in nature. Spring Boot provides an alternative method of working with properties that allows strongly typed beans to govern and validate the configuration of your application.

	When the @EnableConfigurationProperties annotation is applied to your @Configuration, any beans annotated with @ConfigurationProperties will be automatically configured from the Environment properties. This style of configuration works particularly well with the SpringApplication external YAML configuration.

# application.yml

oauth:
    signingKey: ASDGA$%ADFDASFSDFAG


Option 1:  @Component/@ConfigurationProperties class + @Autowired
Option 2:  @ConfigurationProperties class + @EnableConfigurationProperties(class) + @Autowired


Option 1: @Component/@ConfigurationProperties class + @Autowired
--------------------------------------------------------------------------------

1. Create a @Component annotated with @ConfigurationProperties

	@Component
	@ConfigurationProperties(prefix = "oauth")
	public class OAuthProperties {

	  private String signingKey;

	  public String getSigningKey() {
	    return signingKey;
	  }

	  public void setSigningKey(String signingKey) {
	    this.signingKey = signingKey;
	  }

	}

2. Create a @Configuration and @Autowire

	@Configuration
	public class JwtConfiguration {

	  @Autowired
	  private OAuthProperties oAuthProperties;

	  . . .
	}


Option 2: @ConfigurationProperties class + @EnableConfigurationProperties(class) + @Autowired
--------------------------------------------------------------------------------

1. Create a class with @ConfigurationProperties

	@ConfigurationProperties(prefix = "oauth")
	public class OAuthProperties {

	  private String signingKey;

	  public String getSigningKey() {
	    return signingKey;
	  }

	  public void setSigningKey(String signingKey) {
	    this.signingKey = signingKey;
	  }

	}

2. Create a @Configuration class and @EnableConfigurationProperties(OAuthProperties.class)

	@Configuration
	@EnableConfigurationProperties(OAuthProperties.class)
	public class JwtConfiguration {

	  @Autowired
	  private OAuthProperties oAuthProperties;

	  . . .

	}


================================================================================
