
	@@@@@@@@@@@@@@@@@@@

		SpringBoot

	@@@@@@@@@@@@@@@@@@@

Resources

multiple authentication mechanisms in a single app using java config
https://stackoverflow.com/questions/25794680/multiple-authentication-mechanisms-in-a-single-app-using-java-config

multiple security entry points
http://www.baeldung.com/spring-security-multiple-entry-points
https://github.com/eugenp/tutorials/blob/master/spring-security-mvc-boot/src/main/java/org/baeldung/multipleentrypoints/MultipleEntryPointsSecurityConfig.java

@Order
https://stackoverflow.com/questions/45529743/ordersecurityproperties-access-override-order-vs-managementserverproperties-a

Multiple HttpSecurity
https://docs.spring.io/spring-security/site/docs/current/reference/html/jc.html


================================================================================

  @Lazy
  -----

http://dolszewski.com/spring/spring-lazy-annotation-use-cases/


================================================================================

  startup hooks
  *************
http://dolszewski.com/spring/running-code-on-spring-boot-startup/

execute method on bean initialization
-------------------------------------

@Component + @PostConstruct

Just create a class, mark it as a Spring component, and put the app initialization code in a method with the @PostConstruct annotation. In theory, you could use a constructor instead of a separate method but it’s a good practice to separate the object’s construction from its real responsibility.

  @Component
  class AppInitializator {
   
      private static final Logger log = LoggerFactory.getLogger(AppInitializator.class);
   
      @PostConstruct
      private void init() {
          log.info("AppInitializator initialization logic ...");
          // ...
      }
   
  }

You can also create a method with the @PostConstruct annotation inside your main Spring Boot application class. Don’t forget that the main class is also a component managed by the framework.

  @SpringBootApplication
  public class InitDemoApplication {
   
      // ...
   
      @PostConstruct
      private void init() {
          log.info("InitDemoApplication initialization logic ...");
          // ...
      }
   
  }


spring-boot startup hooks
-------------------------

As every Java program, you start execution of such application in the static main method of your entry application class. That’s the point in which you can hook into Spring Boot initialization process.


public static void main(String[] args) {
    SpringApplication application = new SpringApplication(InitDemoApplication.class);
    addInitHooks(application);
    application.run(args);
}

static void addInitHooks(SpringApplication application) {
   application.addListeners((ApplicationListener<ApplicationEnvironmentPreparedEvent>) event -> {
       String version = event.getEnvironment().getProperty("java.runtime.version");
       log.info("Running with Java {}", version);
   });
}


event types
--------------

Here’s the list of possible events sorted by the order in which events are published by Spring Boot on the startup:

ApplicationStartingEvent
ApplicationEnvironmentPreparedEvent
ApplicationContextInitializedEvent
ApplicationPreparedEvent
ApplicationStartedEvent
ApplicationReadyEvent


Run code on startup without embedded Tomcat
--------------------------------------------

if you deploy your application as a WAR file 

  public class InitDemoWarInitializer extends SpringBootServletInitializer {
 
    @Override
    protected SpringApplicationBuilder configure(SpringApplicationBuilder builder) {
        InitDemoApplication.addInitHooks(builder.application());
        return builder.sources(InitDemoApplication.class);
    }
 
  }



================================================================================

  common application properties
  *****************************

https://docs.spring.io/spring-boot/docs/current/reference/html/common-application-properties.html


================================================================================

	SpringBoot 2.0 M4 Security Changes
	**********************************

https://spring.io/blog/2017/09/15/security-changes-in-spring-boot-2-0-m4

Until Spring Boot 1.x, the default auto-configuration secured all of the application endpoints using basic authentication. If actuator was on the classpath, there was a separate security configuration that applied to the actuator endpoints. The way these two auto-configurations would turn on and off was completely independent. Because of this, users wanting to provide custom security found themselves fighting ordering issues with WebSecurityConfigurerAdapters.

Additionally, for actuator endpoints, the effects of the management.security.enabled flag based on whether Spring Security was on the classpath or not was quite confusing.

There were a number of properties under security.* and management.security.* that were applicable only to the auto-configuration provided by Spring Boot. For example, if security.basic.enabled was set to false, setting security.sessions would have absolutely no effect and this turned out to be quite misleading.

	Improvements in 2.0
	-------------------

Default Configuration



================================================================================

  Execute some code before your SpringBootApplication starts
  **********************************************************

Spring Boot provides two interfaces

they get called just before run()

  CommandLineRunner

    provides access to application arguments as string array.

  ApplicationRunner

    wraps the raw application arguments and exposes the ApplicationArguments interface.

    example:  
    https://stackoverflow.com/questions/53506177/how-to-use-jmstemplate-sendandreceive


    @SpringBootApplication
    public class So53506177Application {

        public static void main(String[] args) {
            SpringApplication.run(So53506177Application.class, args);
        }

        private final SimpleMessageConverter converter = new SimpleMessageConverter();

        @Bean
        public ApplicationRunner runner(JmsTemplate jmsTemplate) {
            return args -> {
                jmsTemplate.setReceiveTimeout(20000);
                Message received = jmsTemplate.sendAndReceive("foo", new MessageCreator() {

                    @Override
                    public Message createMessage(Session session) throws JMSException {
                        String msgId = "foo";
                        TextMessage message = session.createTextMessage("foo");
                        message.setJMSCorrelationID(msgId);
                        return message;
                    }
                });
                System.out.println("Reply: " + this.converter.fromMessage(received));
            };
        }

        @Autowired
        private JmsTemplate jmsTemplate;

        @JmsListener(destination = "foo")
        public void consume(final Message message) throws Exception {
            System.out.println("Received: " + this.converter.fromMessage(message));
            jmsTemplate.send(message.getJMSReplyTo(), new MessageCreator() {

                @Override
                public Message createMessage(Session session) throws JMSException {
                    Message responseMsg = session.createTextMessage("bar");
                    responseMsg.setJMSCorrelationID(message.getJMSCorrelationID());
                    return responseMsg;
                }
            });
        }

    }    



================================================================================

	Auto-Configuration
	******************

https://docs.spring.io/spring-boot/docs/current/reference/html/using-boot-using-springbootapplication-annotation.html  

@SpringBootApplication annotation can be used to enable three features:

  @EnableAutoConfiguration: 
    enable Spring Boot’s auto-configuration mechanism

  @ComponentScan: 
    enable @Component scan on the package where the application is located (see the best practices)

  @Configuration: 
    allow to register extra beans in the context or import additional configuration classes

@SpringBootApplication also provides aliases to customize the attributes of @EnableAutoConfiguration and @ComponentScan.


  Disabling Auto-Configuration
  ----------------------------
https://www.baeldung.com/spring-boot-security-autoconfiguration  

Auto-configuration class can be excluded via 

  @SpringBootApplication(exclude = { SecurityAutoConfiguration.class })
  public class SpringBootSecurityApplication {
   
      public static void main(String[] args) {
          SpringApplication.run(SpringBootSecurityApplication.class, args);
      }
  }

or via application.properties file:

spring.autoconfigure.exclude=org.springframework.boot.autoconfigure.security.SecurityAutoConfiguration




  Debug Auto-Configuration
  -------------------------

debug=true 

or

debug: true

or 

  public static void main(String[] args) {

      //just doing this programmatically for demo
      String[] appArgs = {"--debug"};

      SpringApplication app = new SpringApplication(DebugModeExample.class);
      app.setBannerMode(Banner.Mode.OFF);
      app.setLogStartupInfo(false);
      app.run(appArgs);
  }


============================
CONDITIONS EVALUATION REPORT
============================


   SimpleCacheConfiguration matched:
      - Cache org.springframework.boot.autoconfigure.cache.SimpleCacheConfiguration automatic cache type (CacheCondition)
      - @ConditionalOnMissingBean (types: org.springframework.cache.CacheManager; SearchStrategy: all) did not find any beans (OnBeanCondition)


   NoOpCacheConfiguration:
      Did not match:
         - @ConditionalOnMissingBean (types: org.springframework.cache.CacheManager; SearchStrategy: all) found beans of type 'org.springframework.cache.CacheManager' cacheManager (OnBeanCondition)
      Matched:
         - Cache org.springframework.boot.autoconfigure.cache.NoOpCacheConfiguration automatic cache type (CacheCondition)

================================================================================

	SpringBoot Security
	*******************


***************************************
* Keys to different security schemes applied to different parts of your app
* 
* 1. create separate Spring security @Configurations where each one will 
*    configure just one authentication mechanism
*
* 2. each configuration should  specify the URIs it covers
*
* 3. @Configurations need to be ordered.
*
* 4. The @Configurations that need to be ordered are the ones extending
*    ResourceServerConfigurerAdatper and WebSecurityConfigurerAdapter.
*    The classes containing these `protected static classes` are not really
*    @Configurations themselves
* 5. The @Configuration without the @Order annotation is considered last -
*    this is your fallback or fallthru or .. 
*    This could be your resource server config with "/**" pattern matching while
*    higher order configurations could apply alt. authn mechanisms to specific
*    paths like "/actuator/**"
* 6. Use `http.antMatcher(...)` which can be confused with 
*        `http.authorizeRequests().antMatchers(...)` but it's different.



If Spring Security is on the classpath then web applications will be secure by default with ‘basic’ authentication on all HTTP endpoints. 

To add method-level security to a web application you can also add @EnableGlobalMethodSecurity with your desired settings.


	Default SpringBoot Security
	***************************

The default AuthenticationManager has a single user (‘user’ username and random password, printed at INFO level when the application starts up):

	Using default security password: 78fa095d-3f4c-48b1-ad50-e24c31d5cf35


	Order
	*****

Default Security Configuration Order: 100

if you want to apply a resource server filter chain for '/oauth/***', 
you need to specify order as follows:

(1) : [DEFAULT] (= 100)
(2) : 99 or under (e.g: security.oauth2.resource.filter-order=99)


	Override Default SpringBoot Security
	************************************

You can provide a WebSecurityconfigurerAdapter with 

  @Override
  public void configure(AuthenticationManagerBuilder auth) throws Exception {
  	. . .
  }

  @Override
  public void configure(HttpSecurity http) throws Exception {
  	. . .
  }

doesn't matter! - Default SrpingBoot Security will still be in effect.

You need to annotate your WebSecurityConfigurerAdapter with @EnableWebSecurity


	@Order(SecurityProperties.ACCESS_OVERRIDE_ORDER)
	@Configuration
	@EnableWebSecurity
	public class ApplicationEndpointSecurity extends WebSecurityConfigurerAdapter {

	  @Override
	  public void configure(AuthenticationManagerBuilder auth) throws Exception {
	  	. . .
	  }

	  @Override
	  public void configure(HttpSecurity http) throws Exception {
	  	. . .
	  }

	}


and now those overrides will take effect.

	Purpose of @EnableWebSecurity

Apparently to turn off the default and define your own.


From SpringBoot docs:  

https://docs.spring.io/spring-boot/docs/current/reference/htmlsingle/

	To switch off the default web application security configuration completely you can add a bean with @EnableWebSecurity (this does not disable the authentication manager configuration or Actuator’s security). To customize it you normally use external properties and beans of type WebSecurityConfigurerAdapter (e.g. to add form-based login).

	If you add @EnableWebSecurity and also disable Actuator security, you will get the default form-based login for the entire application unless you add a custom WebSecurityConfigurerAdapter.

	If you define a @Configuration with @EnableWebSecurity anywhere in your application it will switch off the default webapp security settings in Spring Boot (but leave the Actuator’s security enabled). To tweak the defaults try setting properties in security.* (see SecurityProperties for details of available settings) and SECURITY section of Common application properties.




NOTE: on ManagementServerProperties
		-----------------------------

If you provide a @Configuration with 

	@Order(ManagementServerProperties.ACCESS_OVERRIDE_ORDER)

it WILL override the Default SpringBoot Security, but for the Management
endpoint ONLY!!!


	/**
	 * Management Endpoint Configuration.
	 */
	@Configuration
	@Order(ManagementServerProperties.ACCESS_OVERRIDE_ORDER)
	public class ManagementEndpointConfiguration extends WebSecurityConfigurerAdapter {

	  private static final Logger log = LoggerFactory.getLogger(ManagementEndpointConfiguration.class);

	  /* management.security.user.name */
	  @Value("${management.security.user.name}")
	  private String name;

	  /* management.security.user.password */
	  @Value("${management.security.user.password}")
	  @NestedConfigurationProperty
	  private String password;

	  @Override
	  protected void configure(AuthenticationManagerBuilder auth) throws Exception {

	    auth
	        .inMemoryAuthentication()
	        .withUser(name)
	        .password(password)
	        .roles("ACTUATOR");
	  }

	  @Override
	  protected void configure(HttpSecurity http) throws Exception {
	    http
	        .authorizeRequests()
	        .anyRequest()
	        .authenticated()
	        .and()
	        .httpBasic();
	  }
	}



================================================================================

	Ordering WebSecurity and ResourceServer ConfigurerAdapters with SB 1.5
	**********************************************************************

to provide a mixed OAuth and BasicAuth security model.


Here is the configuration that orders 
-------------------------------------
1. actuator endpoint - BasicOauth
2. any other endpoint - OAuth
3. option to layer another WebSecurityConfigurerAdapter on top of the first two


BaseSecurityConfiguration.java
------------------------------


import java.io.IOException;
import java.util.Map;
import javax.servlet.http.HttpServletResponse;
import org.jasypt.encryption.StringEncryptor;
import org.jasypt.encryption.pbe.PooledPBEStringEncryptor;
import org.jasypt.encryption.pbe.config.EnvironmentPBEConfig;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.beans.factory.annotation.Value;
import org.springframework.boot.autoconfigure.security.oauth2.resource.JwtAccessTokenConverterConfigurer;
import org.springframework.context.annotation.Bean;
import org.springframework.context.annotation.Configuration;
import org.springframework.context.support.PropertySourcesPlaceholderConfigurer;
import org.springframework.core.annotation.Order;
import org.springframework.security.config.annotation.method.configuration.EnableGlobalMethodSecurity;
import org.springframework.security.config.annotation.web.builders.HttpSecurity;
import org.springframework.security.config.annotation.web.configuration.EnableWebSecurity;
import org.springframework.security.config.annotation.web.configuration.WebSecurityConfigurerAdapter;
import org.springframework.security.config.http.SessionCreationPolicy;
import org.springframework.security.core.userdetails.User;
import org.springframework.security.core.userdetails.UserDetailsService;
import org.springframework.security.oauth2.config.annotation.web.configuration.EnableResourceServer;
import org.springframework.security.oauth2.config.annotation.web.configuration.ResourceServerConfigurerAdapter;
import org.springframework.security.oauth2.config.annotation.web.configurers.ResourceServerSecurityConfigurer;
import org.springframework.security.oauth2.provider.OAuth2Authentication;
import org.springframework.security.oauth2.provider.token.DefaultAccessTokenConverter;
import org.springframework.security.oauth2.provider.token.DefaultTokenServices;
import org.springframework.security.oauth2.provider.token.ResourceServerTokenServices;
import org.springframework.security.oauth2.provider.token.TokenStore;
import org.springframework.security.oauth2.provider.token.store.JwtAccessTokenConverter;
import org.springframework.security.oauth2.provider.token.store.JwtTokenStore;
import org.springframework.security.provisioning.InMemoryUserDetailsManager;
import org.springframework.security.web.AuthenticationEntryPoint;
import org.springframework.security.web.authentication.www.BasicAuthenticationEntryPoint;

/**
 * Provides overall Security configuration for a typical SpringBoot
 * microservice implementing the following:
 * 1. the management endpoint is securing with  Basic Auth.
 * 2. application endpoint resources are secured with OAuth2/JWT-based authentication.
 */
@Configuration
@EnableWebSecurity
public class BaseSecurityConfiguration {

  private static final Logger log = LoggerFactory.getLogger(BaseSecurityConfiguration.class);

  public static final String ACTUATOR_SECURITY_ROLE = "ACTUATOR";


  /* =================  Management Endpoint Security ==================== */

  private String actuatorUserRole;
  /* management.security.user.name */
  @Value("${management.security.user.name}")
  private String actuatorUserName;
  /* management.security.user.password */
  @Value("${management.security.user.password}")
  private String actuatorUserPassword;

  /**
   * Actuator Security Config.
   * Important: this configuration load order is higher than the default of 100,
   * and is also higher than the Resource Server Config with the wild card pattern
   * matching.  This order allows us to match any actuator requests first and
   * apply system user basic auth to those requests.
   * For all other requests a higher order Resource Server configuration with its
   * wild card pattern matching will pick up all other requests.
   * The reason the order number is not 0 or 1 is to leave room for projects to create
   * higher order adapters if needed.
   */
  @Order(1)
  @Configuration
  public static class ActuatorSecurityConfiguration extends WebSecurityConfigurerAdapter {

    @Bean
    AuthenticationEntryPoint authenticationEntryPoint() {
      BasicAuthenticationEntryPoint entryPoint = new BasicAuthenticationEntryPoint();
      entryPoint.setRealmName("actuator realm");
      return entryPoint;
    }

    @Override
    protected void configure(HttpSecurity http) throws Exception {
      //@formatter:off
      http
          .antMatcher("/actuator/**")
          .authorizeRequests()
          .anyRequest().hasRole(ACTUATOR_SECURITY_ROLE)
          .and()
          .httpBasic()
          .authenticationEntryPoint(authenticationEntryPoint());
      //@formatter:on
    }
  }


  /**
   * User Details Service.
   *
   * @return UserDetailsService
   * @throws Exception e
   */
  @Bean
  public UserDetailsService userDetailsService() throws Exception {
    InMemoryUserDetailsManager manager = new InMemoryUserDetailsManager();

    // actuator authorized user
    manager.createUser(
        User
            .withUsername(actuatorUserName)
            .password(actuatorUserPassword)
            .roles(ACTUATOR_SECURITY_ROLE)
            .build()
    );

    return manager;
  }


  /* =================  Application Endpoint Security ==================== */

  @Value("${oauth.signingKey}")
  private String signingKey;

  /**
   * JWT token converter allows us to apply our signing key to enable token validation.
   * @return JwtAccessTokenConverter token converter
   */
  @Bean
  public JwtAccessTokenConverter accessTokenConverter() {
    JwtAccessTokenConverter converter = new JwtAccessTokenConverter();
    converter.setSigningKey(signingKey);
    converter.setAccessTokenConverter(new SfgSecurityConfiguration.JwtConverter());
    return converter;
  }

  /**
   * Token store with our JWT token converter.
   * @return TokenStore
   */
  @Bean
  public TokenStore tokenStore() {
    return new JwtTokenStore(accessTokenConverter());
  }

  /**
   * Resource Server Tokens Services with our TokenStore injected.
   * @return ResourceServerTokenServices
   */
  @Bean
  public ResourceServerTokenServices tokenServices() {
    DefaultTokenServices defaultTokenServices = new DefaultTokenServices();
    defaultTokenServices.setTokenStore(tokenStore());
    defaultTokenServices.setSupportRefreshToken(true);
    return defaultTokenServices;
  }

  /**
   * JWT Converter whose primary purpose is to copy JWT content into
   * OAuth2Authentication enabling access to JWT claims and other details.
   */
  public static class JwtConverter
      extends DefaultAccessTokenConverter
      implements JwtAccessTokenConverterConfigurer {

    @Override
    public void configure(JwtAccessTokenConverter converter) {
      converter.setAccessTokenConverter(this);
    }

    @Override
    public OAuth2Authentication extractAuthentication(Map<String, ?> map) {
      OAuth2Authentication auth = super.extractAuthentication(map);
      auth.setDetails(map); // copy JWT content into Authentication
      return auth;
    }
  }

  @Configuration
  @EnableResourceServer
  @EnableGlobalMethodSecurity(prePostEnabled = true)
  public static class OAuthResourceServerConfiguration extends ResourceServerConfigurerAdapter {

    @Value("${oauth.resourceId}")
    private String resourceId;

    @Autowired
    private TokenStore tokenStore;

    @Autowired
    private JwtAccessTokenConverter accessTokenConverter;

    @Autowired
    private ResourceServerTokenServices tokenServices;

    @Override
    public void configure(HttpSecurity http) throws Exception {
      http
          .antMatcher("/**")
          .authorizeRequests()
          .anyRequest().authenticated()
          .and()
          .sessionManagement()
          .sessionCreationPolicy(SessionCreationPolicy.STATELESS)
          .and()
          .csrf().disable()
          .exceptionHandling()
          .authenticationEntryPoint(
              (request, response, exception)
                  -> response.sendError(HttpServletResponse.SC_UNAUTHORIZED));
    }

    @Override
    public void configure(ResourceServerSecurityConfigurer resources) throws Exception {
      resources.tokenServices(tokenServices);
      // resources.resourceId(null);  // needed if tokens do not contain resourceId
      resources.resourceId(resourceId);  // needed if tokens contain resourceId
    }

  }

  /* =================  Enable Encrypted Properties ==================== */

  @Value("${jasypt.encryptor.password}")
  private String jasyptEncryptorPassword;

  /**
   * Bean for decrypting encrypted password. Password encryption/decryption uses a master password
   * that is stored as environment variable.
   */
  @Bean(name = "jasyptStringEncryptor")
  public StringEncryptor stringEncryptor() throws IOException {
    PooledPBEStringEncryptor encryptor = new PooledPBEStringEncryptor();
    EnvironmentPBEConfig config = new EnvironmentPBEConfig();
    encryptor.setConfig(config);
    config.setPassword(jasyptEncryptorPassword);
    config.setAlgorithm("PBEWithMD5AndDES");
    config.setKeyObtentionIterations("1000");
    config.setPoolSize("1");
    config.setProviderName("SunJCE");
    config.setSaltGeneratorClassName("org.jasypt.salt.RandomSaltGenerator");
    return encryptor;
  }

  /* =================  Enable Property Placeholders ==================== */

  /**
   * PropertySourcesPlaceholderConfigurer resolves ${...} placeholders within bean definition
   * property values.
   */
  @Bean
  public static PropertySourcesPlaceholderConfigurer propertySourcesPlaceholderConfigurer() {
    PropertySourcesPlaceholderConfigurer prop = new PropertySourcesPlaceholderConfigurer();
    prop.setIgnoreUnresolvablePlaceholders(true);
    return prop;
  }

}


Layer another WebSecurityConfigurerAdapter on top of actuator and OAuth resources
-------------------------------------------------------------

using Ordered.HIGHEST_PRECEDENCE


HelloWorldWebSecurityConfiguration.java
---------------------------------------

import org.springframework.context.annotation.Configuration;
import org.springframework.core.Ordered;
import org.springframework.core.annotation.Order;
import org.springframework.security.config.annotation.web.builders.HttpSecurity;
import org.springframework.security.config.annotation.web.configuration.WebSecurityConfigurerAdapter;

/**
 * Tests project team security override.
 */
@Order(Ordered.HIGHEST_PRECEDENCE)
@Configuration
public class HelloWorldWebSecurityConfiguration extends WebSecurityConfigurerAdapter {

  @Override
  protected void configure(HttpSecurity http) throws Exception {
    http
        .antMatcher("/helloworld/**")
        .authorizeRequests()
        .anyRequest()
        .permitAll();
  }
}


supporting cast, providing JwtAuthenticationContext
--------------------------------------------------------

This provides access to the JWT content at the REST resource/controller level:


SomeResourceController.java
---------------------------

import com.acme.cis.domain.DraftClaim;
import com.acme.cis.security.JwtAuthenticationContextFactory.JwtAuthenticationContext;
import com.acme.cis.service.DraftClaimsService;
import java.util.List;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.security.access.prepost.PreAuthorize;
import org.springframework.web.bind.annotation.CrossOrigin;
import org.springframework.web.bind.annotation.RequestMapping;
import org.springframework.web.bind.annotation.RequestMethod;
import org.springframework.web.bind.annotation.RestController;

/**
 * Exposes Draft Claim REST API.
 */
@RestController
@CrossOrigin
public class SomeResourceController {

  private static final Logger log = LoggerFactory.getLogger(SomeResourceController.class);

  @Autowired
  private JwtAuthenticationContext jwtAuthenticationContext;


  /**
   * draft claims REST resource.
   *
   */
  @RequestMapping(value = "/some-stuff", method = RequestMethod.GET)
  @PreAuthorize("hasAuthority('STANDARD_USER')")
  public List<Stuff> someStuff() {

    log.info("JWT username: {}", jwtAuthenticationContext.getUsername());
    log.info("JWT audience: {}", jwtAuthenticationContext.getAudience());
    log.info("JWT scopes: {}", jwtAuthenticationContext.getScopes());
    log.info("JWT expires: {}", jwtAuthenticationContext.getExpiresTimestamp());
    log.info("JWT authorities: {}", jwtAuthenticationContext.getAuthorities());
    log.info("JWT JTI: {}", jwtAuthenticationContext.getJti());
    log.info("JWT client ID: {}", jwtAuthenticationContext.getClientId());

    return stuff;
  }
}





================================================================================

	Formatting Java Time with SpringBoot using Jackson
	**************************************************

https://touk.pl/blog/2016/02/12/formatting-java-time-with-spring-boot-using-json/

add 

    <dependency>
      <groupId>com.fasterxml.jackson.datatype</groupId>
      <artifactId>jackson-datatype-jsr310</artifactId>
      <version>2.9.2</version>
    </dependency>

appliation.yml:

	spring.jackson.serialization.write_dates_as_timestamps: false


Custom formatting

	@JsonFormat(pattern = "dd::MM::yyyy")
	private final LocalDate localDate;

	@JsonFormat(pattern = "KK:mm a")
	private final LocalTime localTime;

now you get

{  
   "version":2,
   "localDate":"01::01::2016",
   "localTime":"10:24 AM",
   "localDateTime":"2016-01-01T10:24",
   "zonedDateTime":"2016-01-01T10:24:00+01:00"
}

================================================================================

	Jetty instead of Tomcat
	***********************

		<dependency>
			<groupId>org.springframework.boot</groupId>
			<artifactId>spring-boot-starter-web</artifactId>
			<exclusions>
				<exclusion>
					<groupId>org.springframework.boot</groupId>
					<artifactId>spring-boot-starter-tomcat</artifactId>
				</exclusion>
			</exclusions>
		</dependency>

		<dependency>
			<groupId>org.springframework.boot</groupId>
			<artifactId>spring-boot-starter-jetty</artifactId>
		</dependency>


================================================================================
================================================================================

  Reading application properties in Spring
  ****************************************

http://www.appsdeveloperblog.com/reading-application-properties-spring-boot/

There are a few ways to read application properties from application.properties
or application.yml in SpringBoot.

1. using Environment object
2. using @Value annotation
3. using @ConfigurationProperties


1. Using Environment object
----------------------------------------  

@Autowired
private Environment env;

String keyValue = env.getProperty(key);

example:

app.title=Learning Spring Boot 
app.description=Working with properties file

  @RestController
  @RequestMapping("app")
  public class AppController {
   
   @Autowired
   private Environment env; // autowired Environment object
   
   @GetMapping("/property")
   public String getPropertyValue(@RequestParam("key") String key) {
    String returnValue = "No value";
    
    String keyValue = env.getProperty(key);  // read property 
    
    if( keyValue!= null && !keyValue.isEmpty()) {
     returnValue = keyValue;
    }
    return returnValue;
   }

  }


3. Reading properties with @ConfigurationProperties
-----------------------------------------------------

Create a POJO object where each class field matches the name of the key 
in a propeprty file.

properties:
-----------

  app.title=Learning Spring Boot 
  app.description=Working with properties file

property object class:
----------------------
  @Component
  @ConfigurationProperties("app")
  public class AppProperties {
   
   private String title;
   private String description;
   public String getTitle() {
    return title;
   }
   public void setTitle(String title) {
    this.title = title;
   }
   public String getDescription() {
    return description;
   }
   public void setDescription(String description) {
    this.description = description;
   }
   
  }

controller
-----------

  @RestController
  @RequestMapping("app")
  public class AppController {
   
   
   @Autowired
   AppProperties myAppProperties;  // injected properties object
   
   
   @GetMapping("/title")
   public String getAppTitle() {
    return myAppProperties.getTitle(); // read title from properties object
   }
   
   @GetMapping("/description")
   public String getAppDescription() {
    return myAppProperties.getDescription();
   }
   
  }


================================================================================

	Typesafe configuration properties
	*********************************

https://docs.spring.io/spring-boot/docs/1.2.0.RELEASE/reference/htmlsingle/#boot-features-external-config-typesafe-configuration-properties


	Using the @Value("${property}") annotation to inject configuration properties can sometimes be cumbersome, especially if you are working with multiple properties or your data is hierarchical in nature. Spring Boot provides an alternative method of working with properties that allows strongly typed beans to govern and validate the configuration of your application.

	When the @EnableConfigurationProperties annotation is applied to your @Configuration, any beans annotated with @ConfigurationProperties will be automatically configured from the Environment properties. This style of configuration works particularly well with the SpringApplication external YAML configuration.

# application.yml

oauth:
    signingKey: ASDGA$%ADFDASFSDFAG


Option 0:  @Configuration + @Bean + @ConfigurationProperties 
Option 1:  @Component/@ConfigurationProperties class + @Autowired
Option 2:  @ConfigurationProperties class + @EnableConfigurationProperties(class) + @Autowired




Option 0: @Configuration + @Bean + @ConfigurationProperties
--------------------------------------------------------------------------------

oauth:
  oauth-server:
    scheme: https
    host: oauth2.company.com
    port: 443
  oauth-client:
    client-id: ead2cd16-d1e9-4508-88b4-763adda70cad
    client-secret: RWTU1vn93V054iNkP1CRWhntSZ9l6nkRKmu2M


1. Create configuration bean classes


  public class OAuthServerConfiguration {
    private String scheme;
    private String host;
    private int port;
    ...
  }

  public class OAuthClientConfiguration {
    private String clientId;
    private String clientSecret;
    ...
  }

2. create @Configuration class


  @Configuration
  public class OAuthConfiguration {

    @Bean
    @ConfigurationProperties(prefix = "oauth.oauth-server")
    public OAuthServerConfiguration oauthServerConfiguration() {
      return new OAuthServerConfiguration();
    }


    @Bean
    @ConfigurationProperties(prefix = "oauth.oauth-client")
    public OAuthClientConfiguration oauthClientConfiguration() {
      return new OAuthClientConfiguration();
    }

  }




Option 1: @Component/@ConfigurationProperties class + @Autowired
--------------------------------------------------------------------------------

1. Create a @Component annotated with @ConfigurationProperties

	@Component
	@ConfigurationProperties(prefix = "oauth")
	public class OAuthProperties {

	  private String signingKey;

	  public String getSigningKey() {
	    return signingKey;
	  }

	  public void setSigningKey(String signingKey) {
	    this.signingKey = signingKey;
	  }

	}

2. Create a @Configuration and @Autowire

	@Configuration
	public class JwtConfiguration {

	  @Autowired
	  private OAuthProperties oAuthProperties;

	  . . .
	}


Option 2: @ConfigurationProperties class + @EnableConfigurationProperties(class) + @Autowired
--------------------------------------------------------------------------------

1. Create a class with @ConfigurationProperties

	@ConfigurationProperties(prefix = "oauth")
	public class OAuthProperties {

	  private String signingKey;

	  public String getSigningKey() {
	    return signingKey;
	  }

	  public void setSigningKey(String signingKey) {
	    this.signingKey = signingKey;
	  }

	}

2. Create a @Configuration class and @EnableConfigurationProperties(OAuthProperties.class)

	@Configuration
	@EnableConfigurationProperties(OAuthProperties.class)
	public class JwtConfiguration {

	  @Autowired
	  private OAuthProperties oAuthProperties;

	  . . .

	}


================================================================================

	Maven resource filtering
	************************

If you are inheriting from the spring-boot-starter-parent POM, the default filter token of the maven-resources-plugins has been changed from ${*} to @ (i.e. @maven.token@ instead of ${maven.token}) to prevent conflicts with Spring-style placeholders. If you have enabled maven filtering for the application.properties directly, you may want to also change the default filter token to use other delimiters.

{
  "claims-intake-api.version" : "@project.version@",
  "build.timestamp" : "@timestamp@"
}

  <build>
    <resources>
      <!-- resource supporting version info -->
      <resource>
        <directory>src/main/resources</directory>
        <filtering>true</filtering>
        <includes>
          <include>${version.info.file}</include>
        </includes>
      </resource>
      <resource>
        <directory>src/main/resources</directory>
        <filtering>false</filtering>
        <excludes>
          <exclude>${version.info.file}</exclude>
        </excludes>
      </resource>
    <resources>


================================================================================
================================================================================

  Spring Boot Error Handling
  **************************

@ExceptionHandler
HandlerExceptionResolver

  Before Spring 3.2, the two main approaches to handling exceptions 
  in a Spring MVC application were:     
    HandlerExceptionResolver or 
    @ExceptionHandler annotation. 
  Both of these have some clear downsides.

  This annotation, if used on methods of controller classes, will serve as the entry point for handling exceptions thrown within this controller only. 


@ControllerAdvice

After 3.2 we now have the new @ControllerAdvice annotation to address the limitations of the previous two solutions.

================================================================================

  @ExceptionHandler 
  -----------------

This works at the @Controller level - define a method to handle exceptions, and
annotate that with @ExceptionHandler

  public class FooController {

    @ExceptionHandler( { CustomExceptionOne.class, CustomExceptionTwo.class })
    public void handleException() {
      // return 404
      ErrorDetails errorDetails = new ErrorDetails(new Date(), ex.getMessage(),
        request.getDescription(false));
      return new ResponseEntity<>(errorDetails, HttpStatus.NOT_FOUND);
    }

  }

This approach has a MAJOR DRAWBACK - the @ExceptionHandler annotated method
is ONLY active for that particular Controller, not globally for the entire
application.

This limitation is often worked around by having all Controllers extends a 
Base Controller class - however, this could be a problem where a Controller 
cannot be made to extend from a such a class.


================================================================================

  HandlerExceptionResolver
  -------------------------
https://www.baeldung.com/exception-handling-for-rest-with-spring


this will resolve ANY exception thrown by the application. 
It will also allow us to implement a uniform exception handling mechanism in our REST API.

Limitations:
 - no control over the body of the response.
 - it’s interacting with the low-level HtttpServletResponse and 
 - it fits into the old MVC model which uses ModelAndView – so there’s still room for improvement.


================================================================================

  @ControllerAdvice
  *****************

Spring 3.2 brings support for a global @ExceptionHandler with the new 
@ControllerAdvice annotation.

It is an "Advice" for multiple controllers, used to enable a single ExceptionHandler
to be applied to multiple controllers.  This way we can define, in just one place, 
how to treat such an exception and this handler will be called when the
exception is thrown from classes that are covered by this @ControllerAdvice.





--------------------------------------------------------------------------------

  selectors
  ---------

@ControllerAdvice(annotations ... )
@ControllerAdvice(assignableTypes ... )
@ControllerAdvice(annotations ... )

  annotations

The subset of controllers affected can be defined by using the following 

AdviceA.class
-------------
@ControllerAdvice(annotations = {UseAdviceA.class})
class AdviceA {

  @ExceptionHandler({SomeException.class})
  public ResponseEntity<String> handleSomeException(SomeException pe, HandlerMethod handlerMethod) {
    String value = handlerMethod.getMethod().getDeclaringClass().getAnnotation(UseAdviceA.class).myValue();
     //value will be ApiController
    return new ResponseEntity<>("SomeString", HttpStatus.BAD_REQUEST);
  }

}  

UseAdviceA.class
----------------
@Target({ElementType.TYPE})
@Retention(RetentionPolicy.RUNTIME)
public @interface UseAdviceA {
  public String myValue();
}  


enabled AdviceA on ApiController.class
---------------------------------------
@RestController
@UseAdviceA(myValue = "ApiController")
@RequestMapping("/myapi")
class ApiController {
 ...
}


  assignableTypes

@ControllerAdvice(assignableTypes = AController.class)
public class AControllerAdvice {
    @ModelAttribute
    public void addModelInformation(Model model){
         //controller specific model information for header and footer added here
    }
}





================================================================================

	Handlers
	********
http://anilkc.me/spring-boot-application-spring-security-custom-handlers/


Custom Login Success Handler
-------------------------------

	onAuthenticationSuccess() method is invoked only when the authentication is 
	successful.

@Component
public class CustomLoginSuccessfulHandler implements AuthenticationSuccessHandler {

  @Override
  public void onAuthenticationSuccess(HttpServletRequest request, HttpServletResponse response, Authentication authentication)
      throws IOException, ServletException {

    response.setStatus(HttpStatus.OK.value());
    response.setContentType(MediaType.APPLICATION_JSON_VALUE);
    response.setContentType("application/json");
    response.setCharacterEncoding("UTF-8");
    JSONObject jsonResponse = new JSONObject();
    jsonResponse.put("message", "Login Successful");
    response.getWriter().write(jsonResponse.toString());
  }

}

	this returns JSON object in response.


Custom login failure handler
-------------------------------

	This method is invoked when the login fails. On failure, this method writes proper message in the response object. We are returning HTTP status 400 in case of failed authentication.

@Component
public class CustomLoginFailureHandler implements AuthenticationFailureHandler {

  @Override
  public void onAuthenticationFailure(HttpServletRequest request, HttpServletResponse response, AuthenticationException exception)
      throws IOException, ServletException {
    
    response.setStatus(HttpStatus.BAD_REQUEST.value());
    response.setContentType(MediaType.APPLICATION_JSON_VALUE);
    response.setCharacterEncoding("UTF-8");
    JSONObject jsonResponse = new JSONObject();
    jsonResponse.put("message", "Invalid Credentials");
    response.getWriter().write(jsonResponse.toString());
  }

}


Custom authentication entry point
------------------------------------

	This handler is invoked if the user tries to access the secured resource without authentication. 

	Please note, this handler avoids Spring Security to redirect to login page. If you want user to be redirected to login page when user is not authenticated and tries to access secured resources, redirect to your login page or your resource. You can avoid this AuthenticationEntryPoint all together to get Spring default login page. 

	The commence method just returns the 403 HTTP status when this handler is invoked.


@Component
public class CustomAuthenticationEntryPoint implements AuthenticationEntryPoint {


  @Override
  public void commence(HttpServletRequest request, HttpServletResponse response, AuthenticationException authException)
      throws IOException, ServletException {
    response.sendError(HttpStatus.FORBIDDEN.value(), HttpStatus.FORBIDDEN.toString());
  }

}

Custom Access Denied Handler
-------------------------------

	When the authenticated user with certain role attempts to access the resource which isn’t available for that user then in that case, this handler is invoked. 

	This handler implements AccessDeniedHandler which has handle method. I have implemented this method to return HTTP 403 status with custom message.

@Component
public class CustomAccessDeniedHandler implements AccessDeniedHandler {

  @Override
  public void handle(HttpServletRequest request, HttpServletResponse response, AccessDeniedException accessDeniedException)
      throws IOException, ServletException {
    response.setStatus(HttpStatus.FORBIDDEN.value());
    response.setContentType(MediaType.APPLICATION_JSON_VALUE);
    response.setCharacterEncoding("UTF-8");
    JSONObject jsonResponse = new JSONObject();
    jsonResponse.put("message", "Access Denied");
    response.getWriter().write(jsonResponse.toString());
  }

}

Logout successful handler
-----------------------------

this handler returns logout successful message. This handler is invoked when the logout process is successful.

@Component
public class CustomLogoutSuccessfulHandler implements LogoutSuccessHandler {

  @Override
  public void onLogoutSuccess(HttpServletRequest request, HttpServletResponse response, Authentication authentication)
      throws IOException, ServletException {

    response.setStatus(HttpStatus.OK.value());
    response.setContentType(MediaType.APPLICATION_JSON_VALUE);
    response.setCharacterEncoding("UTF-8");
    JSONObject jsonResponse = new JSONObject();
    jsonResponse.put("message", "Logout Successful");
    response.getWriter().write(jsonResponse.toString());
  }

}

WebSecurityConfig
--------------------------------------

@Configuration
@EnableWebSecurity
public class WebSecurityConfig extends WebSecurityConfigurerAdapter {


  @Autowired
  private CustomLoginSuccessfulHandler loginSuccessfulHandler;

  @Autowired
  private CustomLoginFailureHandler loginFailureHandler;

  @Autowired
  private CustomLogoutSuccessfulHandler logoutSuccessfulHandler;

  @Autowired
  private CustomAccessDeniedHandler customAccessDeniedHandler;

  @Autowired
  private CustomAuthenticationEntryPoint customAuthenticationEntryPoint;

  @Bean
  @Override
  public AuthenticationManager authenticationManagerBean() throws Exception {
    return super.authenticationManagerBean();
  }

  @Override
  protected void configure(AuthenticationManagerBuilder auth) throws Exception {
  //@formatter:off
    auth.inMemoryAuthentication()
                .withUser("user").password("password").roles("USER")
                .and()
                .withUser("admin").password("password").roles("ADMIN");
  // @formatter:on

  }

  @Override
  protected void configure(HttpSecurity http) throws Exception {

  //@formatter:off
      http
      .csrf().disable()
          .formLogin()
              .loginProcessingUrl("/auth/login")
              .successHandler(loginSuccessfulHandler)
              .failureHandler(loginFailureHandler)
          .and()
              .logout()
              .logoutUrl("/auth/logout")
              .logoutSuccessHandler(logoutSuccessfulHandler)
          .and()
            .authorizeRequests()
            .antMatchers("/auth/login").permitAll()
            .antMatchers("/secure/admin").access("hasRole('ADMIN')")
            .anyRequest().authenticated()
           .and()
             .exceptionHandling().accessDeniedHandler(customAccessDeniedHandler)
             .authenticationEntryPoint(customAuthenticationEntryPoint)
          .and()
            .anonymous()
              .disable();
  // @formatter:on
  }
  
}

================================================================================
================================================================================

	Import @Configurations from library
	***********************************

some library
---------------

	@Configuration // allows to import this class
	@ComponentScan // Scan for beans and other configuration classes
	public class SomeLibrary {

	    // no main needed here
	
	}

app using the library
---------------------

	@SpringBootApplication
	@Import(SomeLibrary.class) // import the library
	public class OtherApplication {

	    // just put your standard main in this class
	
	}


================================================================================

	org.slf4j.MDC versus ThreadLocal<ExecutionContext>
	**************************************************

slf4j and logback/log4j offer MDC (Mapped Diagnostic Context).

so, you could use 

	MDC.put("executionContext", executionContext)

and then 

	%d %-5level [%thread] %logger [%X{executionContext}] %msg%n

and all log entries will get the execution context injected into the log entry.

Seems like a no-brainer.
The docs say "MDC managed contextual information on a per thread basis".


However, here are the reasons not to:

1. Using MDC, makes execution context data available to the logging system, 
   there may be other consumers of the execution context data for which
   MDC is of no help.
   In this case a use of a ExecutionContextHolder with 
   ThreadLocal<ExecutionContext> will provide a more generic solution.

2. I may not want the context data in EVERY log entry.

3. Sounds like there is a concern with using MDC in a pooled thread env:

MDC and Thread Pools: A Bad Combination
http://ashtonkemerling.com/blog/2017/09/01/mdc-and-threadpools/

	On paper you could generate a UUID per request, insert it into the MDC and presto you have a UUID per request in each log line! Since threads are created per request, the MDC will be empty each time.

	Except, that’s not really how Java programming works these days. Threads are expensive, and so for the sake of efficiency modern Java aims to minimize the number of threads created. This means using non-blocking IO (NIO), or reusing threads via Thread Pools where possible, which avoids creating new threads. 

	So, what happens to our MDC when we reuse threads? 
	Well, we end up with the wrong MDC!

For the above reasons, using your own ExecutionContextHolder may be a better idea
for the moment.


================================================================================

  @EnableScheduling and @Scheduled
  ********************************

To schedule a job in spring-boot app to run periodically

@EnableScheduing

  internally imports the SchedulingConfiguration via 
  @Import(SchedulingConfiguration.class)


@SpringBootApplication
@EnableScheduling
public class DemoApplication {


@Scheduled

add on methods which you want to schedule
methods must NOT have arguments.

ScheduledAnnotationBeanPostProcessor scans all declared beans for the presense
of the @Scheduled annotations.

  @Scheduled(
      initialDelay = 1000,
      fixedRate = 10000
  )
  public void scheduledCurrentTime() {
    logger.info("Current time: {}", Calendar.getInstance().getTime());
  }


================================================================================

  Enabling HTTPS
  **************

Configuring key-store and trust-store.

https://docs.spring.io/spring-boot/docs/current/reference/html/common-application-properties.html

server.ssl.ciphers= # Supported SSL ciphers.
server.ssl.client-auth= # Whether client authentication is wanted ("want") or needed ("need"). Requires a trust store.
server.ssl.enabled= # Enable SSL support.
server.ssl.enabled-protocols= # Enabled SSL protocols.
server.ssl.key-alias= # Alias that identifies the key in the key store.
server.ssl.key-password= # Password used to access the key in the key store.
server.ssl.key-store= # Path to the key store that holds the SSL certificate (typically a jks file).
server.ssl.key-store-password= # Password used to access the key store.
server.ssl.key-store-provider= # Provider for the key store.
server.ssl.key-store-type= # Type of the key store.
server.ssl.protocol=TLS # SSL protocol to use.
server.ssl.trust-store= # Trust store that holds SSL certificates.
server.ssl.trust-store-password= # Password used to access the trust store.
server.ssl.trust-store-provider= # Provider for the trust store.
server.ssl.trust-store-type= # Type of the trust store.


https://docs.spring.io/spring-cloud-dataflow/docs/1.0.1.RELEASE/reference/html/getting-started-security.html

By default, the dashboard, management, and health endpoints use HTTP as a transport. You can switch to HTTPS easily, by adding a certificate to your configuration in application.yml.

server:
  port: 8443                                         1
  ssl:
    key-alias: yourKeyAlias                          2
    key-store: path/to/keystore                      3
    key-store-password: yourKeyStorePassword         4
    key-password: yourKeyPassword                    5
    trust-store: path/to/trust-store                 6
    trust-store-password: yourTrustStorePassword     7

1 change the port to a more common HTTPs-typical port.

2 The alias (or name) under which the key is stored in the keystore.

3 The path to the keystore file. Classpath resources may also be specified, by using the classpath prefix: classpath:path/to/keystore

4 The password of the keystore.

5 The password of the key.

6 The path to the truststore file. Classpath resources may also be specified, by using the classpath prefix: classpath:path/to/trust-store

7 The password of the trust store.

================================================================================

  WebMvcConfigurerAdapter is deprecated
  *************************************

This warning will appear if we’re using Spring version 5 (or Spring Boot 2), either when upgrading an existing application or building a new application with the old API.

In earlier versions of Spring, up to and including version 4, if we wanted to configure a web application, we could make use of the WebMvcConfigurerAdapter class:

  @Configuration
  public WebConfig extends WebMvcConfigurerAdapter {
       
      // ...
  }  

Java 8 added the concept of default methods in interfaces. Naturally, the Spring team updated the framework to make full use of the new Java language features.

Now, use

  @Configuration
  public WebConfig implements WebMvcConfigurer {
      // ...
  }

================================================================================

  logback configuration for spring-boot
  *************************************

spring-boot injects spring environment into system properties.
https://docs.spring.io/spring-boot/docs/current/reference/html/boot-features-logging.html#boot-features-custom-log-configuration

so application.yml properties like:

logging:
  config: classpath:logback-spring.xml
  path: /var/log
  file: my-cool-app.log
  pattern:
    file: "[%d] [%-5level] [%thread] [%logger] - [%msg]%n"

get translated to

  LOG_PATH
  LOG_FILE
  FILE_LOG_PATTERN    

respectively.  Now you can use them in `logback-spring.xml`:

<?xml version="1.0" encoding="UTF-8"?>
<configuration>
  <include resource="org/springframework/boot/logging/logback/defaults.xml" />

  <appender name="FILE"
    class="ch.qos.logback.core.rolling.RollingFileAppender">
    <file>${LOG_PATH}/${LOG_FILE}.log</file>
    <rollingPolicy
      class="ch.qos.logback.core.rolling.SizeAndTimeBasedRollingPolicy">
      <!-- daily rollover -->
      <fileNamePattern>${LOG_PATH}/${LOG_FILE}.%d{yyyy-MM-dd}.%i.log</fileNamePattern>
      <!-- each file should be at most 100MB, keep 30 days worth of history, 
        but at most 500MB -->
      <maxFileSize>100MB</maxFileSize>
      <maxHistory>30</maxHistory>
      <totalSizeCap>500MB</totalSizeCap>
    </rollingPolicy>
    <encoder>
      <pattern>${FILE_LOG_PATTERN}</pattern>
    </encoder>
  </appender>
  
  <appender name="STDOUT" class="ch.qos.logback.core.ConsoleAppender">
    <encoder>
      <pattern>${CONSOLE_LOG_PATTERN}</pattern>
    </encoder>
  </appender>
  
  <root level="DEBUG">
    <appender-ref ref="STDOUT" />
    <appender-ref ref="FILE" />
  </root>

</configuration>

CONSOLE appender is just an example - probably won't need it in prod .. 


================================================================================

  log REST request/response HTTP Headers 
  **************************************

One option: 
https://www.baeldung.com/spring-http-logging  
-------------------------------------------------------------------------

@Configuration
public class RequestLoggingFilterConfig {
 
    @Bean
    public CommonsRequestLoggingFilter logFilter() {
        CommonsRequestLoggingFilter filter
          = new CommonsRequestLoggingFilter();
        filter.setIncludeQueryString(true);
        filter.setIncludePayload(false);
        filter.setMaxPayloadLength(10000);
        filter.setIncludeHeaders(true);
        filter.setAfterMessagePrefix("REQUEST DATA : ");
        return filter;
    }
}

application.yml:

logging.level:
  org.springframework.web.filter.CommonsRequestLoggingFilter: DEBUG

Output:

2018-09-07 16:40:32.915 DEBUG 18971 --- [nio-9042-exec-2] o.s.w.f.CommonsRequestLoggingFilter      : Before request [uri=/blah;headers={gtid=[abc-123-456-xyz], cache-control=[no-cache], postman-token=[1ea3d58a-badb-48aa-8ff0-3a8f29ab32bd], authorization=[Bearer xyz], user-agent=[PostmanRuntime/7.2.0], accept=[*/*], host=[localhost:9042], accept-encoding=[gzip, deflate], connection=[keep-alive]}]

. . .

2018-09-07 16:40:33.110 DEBUG 18971 --- [nio-9042-exec-2] o.s.w.f.CommonsRequestLoggingFilter      : REQUEST DATA : uri=/blah;headers={gtid=[abc-123-456-xyz], cache-control=[no-cache], postman-token=[1ea3d58a-badb-48aa-8ff0-3a8f29ab32bd], authorization=[Bearer xyz], user-agent=[PostmanRuntime/7.2.0], accept=[*/*], host=[localhost:9042], accept-encoding=[gzip, deflate], connection=[keep-alive]}]

-------------------------------------------------------------------------

Another option:  extend OncePerRequestFilter implement Order

https://gist.github.com/int128/e47217bebdb4c402b2ffa7cc199307ba
http://slackspace.de/articles/log-request-body-with-spring-boot/


@Configuration
public class RequestLoggingFilterConfiguration {

  @Bean
  public HttpRequestLoggingFilter logFilter() {
    return new HttpRequestLoggingFilter();
  }

}


HttpRequestLoggingFilter.java
-----------------------------

import java.io.IOException;
import java.io.UnsupportedEncodingException;
import java.util.Arrays;
import java.util.Collections;
import java.util.List;
import java.util.stream.Stream;
import javax.servlet.FilterChain;
import javax.servlet.ServletException;
import javax.servlet.http.HttpServletRequest;
import javax.servlet.http.HttpServletResponse;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;
import org.springframework.core.Ordered;
import org.springframework.http.HttpStatus;
import org.springframework.http.MediaType;
import org.springframework.web.filter.OncePerRequestFilter;
import org.springframework.web.util.ContentCachingRequestWrapper;
import org.springframework.web.util.ContentCachingResponseWrapper;

/**
 * This filter logs HTTP request headers.
 */
public class HttpRequestLoggingFilter extends OncePerRequestFilter implements Ordered {

  private final static Logger logger = LoggerFactory.getLogger(HttpRequestLoggingFilter.class);

  private static final List<MediaType> VISIBLE_TYPES = Arrays.asList(
      MediaType.valueOf("text/*"),
      MediaType.APPLICATION_FORM_URLENCODED,
      MediaType.APPLICATION_JSON,
      MediaType.APPLICATION_XML,
      MediaType.valueOf("application/*+json"),
      MediaType.valueOf("application/*+xml"),
      MediaType.MULTIPART_FORM_DATA
  );

  // put filter at the end of all other filters to make sure we are processing after all others
  private static int order = Ordered.LOWEST_PRECEDENCE - 8;

  @Override
  public int getOrder() {
    return order;
  }

  private boolean includeHeaders = true;
  private boolean includePayload = false;
  private boolean logResponse = false;

  public void setIncludeHeaders(boolean includeHeaders) {
    this.includeHeaders = includeHeaders;
  }

  public void setIncludePayload(boolean includePayload) {
    this.includePayload = includePayload;
  }

  public void setLogResponse(boolean logResponse) {
    this.logResponse = logResponse;
  }

  @Override
  protected void doFilterInternal(HttpServletRequest request, HttpServletResponse response,
      FilterChain filterChain) throws ServletException, IOException {

    if (isAsyncDispatch(request)) {
      filterChain.doFilter(request, response);
    } else {
      doFilterWrapped(wrapRequest(request), wrapResponse(response), filterChain);
    }

  }

  protected void doFilterWrapped(ContentCachingRequestWrapper request,
      ContentCachingResponseWrapper response, FilterChain filterChain)
      throws ServletException, IOException {
    try {
      beforeRequest(request, response);
      filterChain.doFilter(request, response);
    } finally {
      afterRequest(request, response);
      response.copyBodyToResponse();
    }
  }

  protected void beforeRequest(ContentCachingRequestWrapper request,
      ContentCachingResponseWrapper response) {
    if (logger.isInfoEnabled() && this.includeHeaders) {
      logRequestHeader(request, request.getRemoteAddr() + "|>");
    }
  }

  protected void afterRequest(ContentCachingRequestWrapper request,
      ContentCachingResponseWrapper response) {
    if (logger.isInfoEnabled()) {
      if (this.includePayload) {
        logRequestBody(request, request.getRemoteAddr() + "|>");
      }
      if (this.logResponse) {
        logResponse(response, request.getRemoteAddr() + "|<");
      }
    }
  }

  private void logRequestHeader(ContentCachingRequestWrapper request, String prefix) {
    final String queryString = request.getQueryString();
    if (queryString == null) {
      logger.info("{} {} {}", prefix, request.getMethod(), request.getRequestURI());
    } else {
      logger.info("{} {} {}?{}", prefix, request.getMethod(), request.getRequestURI(), queryString);
    }
    Collections.list(request.getHeaderNames()).forEach(headerName ->
        Collections.list(request.getHeaders(headerName)).forEach(headerValue ->
            logger.info("{} {}: {}", prefix, headerName, headerValue)));
    logger.info("{}", prefix);
  }

  private void logRequestBody(ContentCachingRequestWrapper request, String prefix) {
    final byte[] content = request.getContentAsByteArray();
    if (content.length > 0) {
      logContent(content, request.getContentType(), request.getCharacterEncoding(), prefix);
    }
  }

  private void logResponse(ContentCachingResponseWrapper response, String prefix) {
    final int status = response.getStatus();
    logger.info("{} {} {}", prefix, status, HttpStatus.valueOf(status).getReasonPhrase());
    response.getHeaderNames().forEach(headerName ->
        response.getHeaders(headerName).forEach(headerValue ->
            logger.info("{} {}: {}", prefix, headerName, headerValue)));

    if (this.includePayload) {
      logger.info("{}", prefix);
      final byte[] content = response.getContentAsByteArray();
      if (content.length > 0) {
        logContent(content, response.getContentType(), response.getCharacterEncoding(), prefix);
      }
    }

  }

  private void logContent(byte[] content, String contentType, String contentEncoding,
      String prefix) {
    final MediaType mediaType = MediaType.valueOf(contentType);
    final boolean visible = VISIBLE_TYPES.stream()
        .anyMatch(visibleType -> visibleType.includes(mediaType));
    if (visible) {
      try {
        final String contentString = new String(content, contentEncoding);
        Stream
            .of(contentString.split("\r\n|\r|\n"))
            .forEach(line -> logger.info("{} {}", prefix, line));
      } catch (UnsupportedEncodingException e) {
        logger.info("{} [{} bytes content]", prefix, content.length);
      }
    } else {
      logger.info("{} [{} bytes content]", prefix, content.length);
    }
  }

  private static ContentCachingRequestWrapper wrapRequest(HttpServletRequest request) {
    if (request instanceof ContentCachingRequestWrapper) {
      return (ContentCachingRequestWrapper) request;
    } else {
      return new ContentCachingRequestWrapper(request);
    }
  }

  private static ContentCachingResponseWrapper wrapResponse(HttpServletResponse response) {
    if (response instanceof ContentCachingResponseWrapper) {
      return (ContentCachingResponseWrapper) response;
    } else {
      return new ContentCachingResponseWrapper(response);
    }
  }
}



================================================================================

  Respond with 303 "See Other"
  ****************************

  header("HTTP/1.1 303 See Other");
  header("Location: http://some.host/new/location/here");  

spring-boot:

  HttpHeaders headers = new HttpHeaders();
  headers.add("Location", something.getRedirectUrl());
  return new ResponseEntity<>(
      "See Other",
      headers,
      HttpStatus.SEE_OTHER);


================================================================================

  JavaMailSender
  **************
Spring Boot will automatically configure the ability to send mail when mail properties and the java mail library are detected on the classpath.

<dependency>
  <groupId>org.springframework.boot</groupId>
  <artifactId>spring-boot-starter-mail</artifactId>
</dependency>

To be able to send mail, you need to configure the appropriate spring.mail properties. At least the spring.mail.host property is needed; the other properties are optional.

spring.mail.host              The SMTP server host
spring.mail.port              The SMTP sever port (default 25)
spring.mail.username  Username to use for connecting to the SMTP server
spring.mail.password  Password to use for connecting to the SMTP server
spring.mail.protocol  The protocol used by the SMTP server (default smtp)
spring.mail.test-connection 
  Test if the SMTP server is available at startup (default false)
spring.mail.default-encoding
  Encoding used for MIME messages (default UTF-8)
spring.mail.properties.* 
  Additional properties to be set on the JavaMail Session
spring.mail.jndi-name 
  JNDI name of the JavaMail Session, can be used when deploying to a JEE server with preconfigured JavaMail Sessions in JNDI.


Sending a Plain Text E-mail
-----------------------------
With the added dependencies and spring.mail properties, Spring Boot will add a
preconfigured JavaMailSenderImpl as a bean to the ApplicationContext. This bean
can be autowired into components, by either using an @Autowired field or through
constructors or, as shown here, as dependencies in @Bean annotated methods.

import org.springframework.boot.ApplicationRunner;
import org.springframework.boot.SpringApplication;
import org.springframework.boot.autoconfigure.SpringBootApplication;
import org.springframework.context.annotation.Bean;
import org.springframework.mail.javamail.JavaMailSender;
import org.springframework.mail.javamail.MimeMessageHelper;
import javax.mail.Message;

@SpringBootApplication
public class MailSenderApplication {
  public static void main(String[] args) {
    SpringApplication.run(MailSenderApplication.class, args);
  }

  @Bean
  public ApplicationRunner startupMailSender(JavaMailSender mailSender) {
    return (args) -> {
      mailSender.send((msg) -> {
        var helper = new MimeMessageHelper(msg);
        helper.setTo("recipient@some.where");
        helper.setFrom("spring-boot-2-recipes@apress.com");
        helper.setSubject("Status message");
      helper.setText("All is well.");
      });
    };
  }
}

The MailSenderApplication will send an e-mail when the application finished
starting. The startupMailSender is an ApplicationRunner, which takes
the preconfigured JavaMailSender to send a mail message.

Using Thymeleaf for E-mail Templates
------------------------------------

Spring Boot has some nice support for using Thymeleaf as a templating solution;
however, the default setup is mainly for using Thymeleaf for webpages. It is, however, very possible to use Thymeleaf for e-mail templates.

First, add the spring-boot-starter-thymeleaf as a dependency. This will pull in
all the needed Thymeleaf dependencies and will automatically configure the Thymeleaf
TemplateEngine, which we need to generate the HTML content.

<dependency>
  <groupId>org.springframework.boot</groupId>
  <artifactId>spring-boot-starter-thymeleaf</artifactId>
</dependency>

By default, the Spring configured Thymeleaf TemplateEngine will resolve the HTML
templates from the templates directory under src/main/resources. Add a file named
`email.html` to this directory and make a nice looking e-mail message from it.

<!DOCTYPE html>
<html xmlns:th="http://www.thymeleaf.org">
<head>
<meta http-equiv="Content-Type" content="text/html; charset=UTF-8" />
</head>
<body>
<p><strong th:text="${msg}">Some email content will be here.</strong></p>
<p>
Kind Regards,
  Your Application
</p>
</body>
</html>


The th:text is a Thymeleaf tag and will replace the content with the value of that
attribute. Of Course we would need to pass in a value for that attribute from our mail sending/generating code.

import org.springframework.boot.ApplicationRunner;
import org.springframework.boot.SpringApplication;
import org.springframework.boot.autoconfigure.SpringBootApplication;
import org.springframework.context.annotation.Bean;
import org.springframework.context.i18n.LocaleContextHolder;
import org.springframework.mail.javamail.JavaMailSender;
import org.springframework.mail.javamail.MimeMessageHelper;
import org.thymeleaf.context.Context;
import org.thymeleaf.spring5.SpringTemplateEngine;
import javax.mail.Message;
import java.util.Collections;

@SpringBootApplication
public class MailSenderApplication {

  public static void main(String[] args) {
    SpringApplication.run(MailSenderApplication.class, args);
  }

  @Bean
  public ApplicationRunner startupMailSender(
  JavaMailSender mailSender,
  SpringTemplateEngine templateEngine) {

    return (args) -> {
      mailSender.send((msg) -> {
        var helper = new MimeMessageHelper(msg);
        helper.setTo("recipient@some.where");
        helper.setFrom("spring-boot-2-recipes@apress.com");
        helper.setSubject("Status message");
        var context = new Context(
        LocaleContextHolder.getLocale(),
        Collections.singletonMap("msg", "All is well!"));
        var body = templateEngine.process("email.html", context);
        helper.setText(body, true);
      });
    };
  }
}


The code still is very similar to the code as it was, but with this difference now we
also have a SpringTemplateEnginge at our disposable to generate the HTML content
for our e-mail. We use the process method to select the template we want to render,
email.html, and pass in a Context object. The Context object is used by Thymeleaf to
resolve the attributes, in our case the msg one.

================================================================================

  build information at runtime
  ****************************

https://www.vojtechruzicka.com/spring-boot-version/  

spring-boot-maven-plugin
------------------------

<plugin>
    <groupId>org.springframework.boot</groupId>
    <artifactId>spring-boot-maven-plugin</artifactId>
    <executions>
        <execution>
            <id>build-info</id>
            <goals>
                <goal>build-info</goal>
            </goals>
        </execution>
    </executions>
</plugin>


@Autowired
BuildProperties buildProperties;


// Artifact's name from the pom.xml file
buildProperties.getName();
// Artifact version
buildProperties.getVersion();
// Date and Time of the build
buildProperties.getTime();
// Artifact ID from the pom file
buildProperties.getArtifact();
// Group ID from the pom file
buildProperties.getGroup();


adding custom properties
-------------------------

<plugin>
    <groupId>org.springframework.boot</groupId>
    <artifactId>spring-boot-maven-plugin</artifactId>
    <executions>
        <execution>
            <goals>
                <goal>build-info</goal>
            </goals>
            <configuration>
                <additionalProperties>
                    <java.version>${java.version}</java.version>
                    <some.custom.property>some value</some.custom.property>
                </additionalProperties>
            </configuration>
        </execution>
    </executions>
</plugin>


You can pass a value directly or use your custom properties defined in the <properties> section of your pom.xml and then referenced using ${property.name} placeholder.

You can access custom properties defined this way by calling  buildProperties.get("property.name").


For Gradle projects, custom properties can be defined this way:

springBoot {
    buildInfo {
        properties {
            additional = [
                'property.name': 'property value',
                'other.property': 'different.value'
            ]
        }
    }
}

Under the hood
-----------------------

When build-info of spring-boot-maven-plugin is run, it generates a property file containing all the build information. By default, it is located at  ${project.build.outputDirectory}/META-INF/build-info.properties, but you can customize it by providing outputFile parameter. The file looks something like this:

#Properties
#Sat Jun 23 15:58:56 CEST 2018
build.version=0.0.1-SNAPSHOT
build.group=com.vojtechruzicka
build.name=spring-rest-docs-example
build.artifact=spring-rest-docs-example
build.time=2018-06-23T13\:58\:56.742472800Z

When Spring detects there is this file on the classpath, it creates BuildProperties bean unless it is explicitly declared. This is configured in  org.springframework.boot.autoconfigure.info.ProjectInfoAutoConfiguration. This is a nice example of Spring Boot Auto-Configuration, where certain beans can be created just by having specific files on the classpath.


@ConditionalOnResource(resources = 
"${spring.info.build.location:classpath:META-INF/build-info.properties}")
@ConditionalOnMissingBean
@Bean
public BuildProperties buildProperties() throws Exception {
    return new BuildProperties(
            loadFrom(this.properties.getBuild().getLocation(), 
            "build"));
}


================================================================================

  Detecting Spring profiles
  *************************

@Autowired
private Environment environment;

environment.getActiveProfiles();


================================================================================

  Loading resources from classpath
  ********************************

1. manually

    return new ClassPathResource("data/employees.dat", this.getClass().getClassLoader());

or thru a specified class

    return new ClassPathResource(
      "data/employees.dat", 
      Employee.class.getClassLoader());


2. using @Value


  @Component
  public class MyRunner implements CommandLineRunner {

      @Value("classpath:my-resource.txt")
      private Resource res;

      ...
  }

3. using ResourceLoader


  @Component
  public class MyRunner implements CommandLineRunner {

    @Autowired
    private ResourceLoader resourceLoader;


    public void doSomething() throws Exception {

      Resource res = resourceLoader.getResource("classpath:my-resource.txt");
      try (Reader reader = new InputStreamReader(res.getInputStream(), UTF_8)) {

          String fileText = FileCopyUtils.copyToString(reader);
          // do something with the string

      } catch (IOException e) {
          throw new UncheckedIOException(e);
      }

    }

  }
================================================================================
