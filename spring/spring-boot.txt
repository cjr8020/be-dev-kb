
	@@@@@@@@@@@@@@@@@@@

		SpringBoot

	@@@@@@@@@@@@@@@@@@@

Resources

multiple authentication mechanisms in a single app using java config
https://stackoverflow.com/questions/25794680/multiple-authentication-mechanisms-in-a-single-app-using-java-config

multiple security entry points
http://www.baeldung.com/spring-security-multiple-entry-points
https://github.com/eugenp/tutorials/blob/master/spring-security-mvc-boot/src/main/java/org/baeldung/multipleentrypoints/MultipleEntryPointsSecurityConfig.java

@Order
https://stackoverflow.com/questions/45529743/ordersecurityproperties-access-override-order-vs-managementserverproperties-a

Multiple HttpSecurity
https://docs.spring.io/spring-security/site/docs/current/reference/html/jc.html


================================================================================

	SpringBoot 2.0 M4 Security Changes
	**********************************

https://spring.io/blog/2017/09/15/security-changes-in-spring-boot-2-0-m4

Until Spring Boot 1.x, the default auto-configuration secured all of the application endpoints using basic authentication. If actuator was on the classpath, there was a separate security configuration that applied to the actuator endpoints. The way these two auto-configurations would turn on and off was completely independent. Because of this, users wanting to provide custom security found themselves fighting ordering issues with WebSecurityConfigurerAdapters.

Additionally, for actuator endpoints, the effects of the management.security.enabled flag based on whether Spring Security was on the classpath or not was quite confusing.

There were a number of properties under security.* and management.security.* that were applicable only to the auto-configuration provided by Spring Boot. For example, if security.basic.enabled was set to false, setting security.sessions would have absolutely no effect and this turned out to be quite misleading.

	Improvements in 2.0
	-------------------

Default Configuration




================================================================================

	Structure Spring Boot application
	*********************************

Locate your main application class in root package above all other classes.

@EnableAutoConfiguration is often placed in your main class, and is implicitly
defines a base "search package" for certain items.
E.g. if you're wiring a JPA application, the package of the @EnableAutoConfiguration class will be used to search for @Entity items. 

Using root package allows the @ComponentScan annotation to be used without 
needed to specify a "basePackage" attribute.

Typical layout:

com
 +- example
     +- myproject
         +- Application.java //@SpringBootApplication
         |
         +- domain
         |   +- Customer.java
         |   +- CustomerRepository.java
         |
         +- service
         |   +- CustomerService.java
         |
         +- web
             +- CustomerController.java


package com.example.myproject;

@Configuration
@EnableAutoConfiguration
@ComponentScan
public class Application {

    public static void main(String[] args) {
        SpringApplication.run(Application.class, args);
    }

}


================================================================================

	SpringBoot Security
	*******************


***************************************
* Keys to different security schemes applied to different parts of your app
* 
* 1. create separate Spring security @Configurations where each one will 
*    configure just one authentication mechanism
*
* 2. each configuration should  specify the URIs it covers
*
* 3. @Configurations need to be ordered.
*
* 4. The @Configurations that need to be ordered are the ones extending
*    ResourceServerConfigurerAdatper and WebSecurityConfigurerAdapter.
*    The classes containing these `protected static classes` are not really
*    @Configurations themselves
* 5. The @Configuration without the @Order annotation is considered last -
*    this is your fallback or fallthru or .. 
*    This could be your resource server config with "/**" pattern matching while
*    higher order configurations could apply alt. authn mechanisms to specific
*    paths like "/actuator/**"
* 6. Use `http.antMatcher(...)` which can be confused with 
*        `http.authorizeRequests().antMatchers(...)` but it's different.



If Spring Security is on the classpath then web applications will be secure by default with ‘basic’ authentication on all HTTP endpoints. 

To add method-level security to a web application you can also add @EnableGlobalMethodSecurity with your desired settings.


	Default SpringBoot Security
	***************************

The default AuthenticationManager has a single user (‘user’ username and random password, printed at INFO level when the application starts up):

	Using default security password: 78fa095d-3f4c-48b1-ad50-e24c31d5cf35


	Order
	*****

Default Security Configuration Order: 100

if you want to apply a resource server filter chain for '/oauth/***', 
you need to specify order as follows:

(1) : [DEFAULT] (= 100)
(2) : 99 or under (e.g: security.oauth2.resource.filter-order=99)


	Override Default SpringBoot Security
	************************************

You can provide a WebSecurityconfigurerAdapter with 

  @Override
  public void configure(AuthenticationManagerBuilder auth) throws Exception {
  	. . .
  }

  @Override
  public void configure(HttpSecurity http) throws Exception {
  	. . .
  }

doesn't matter! - Default SrpingBoot Security will still be in effect.

You need to annotate your WebSecurityConfigurerAdapter with @EnableWebSecurity


	@Order(SecurityProperties.ACCESS_OVERRIDE_ORDER)
	@Configuration
	@EnableWebSecurity
	public class ApplicationEndpointSecurity extends WebSecurityConfigurerAdapter {

	  @Override
	  public void configure(AuthenticationManagerBuilder auth) throws Exception {
	  	. . .
	  }

	  @Override
	  public void configure(HttpSecurity http) throws Exception {
	  	. . .
	  }

	}


and now those overrides will take effect.

	Purpose of @EnableWebSecurity

Apparently to turn off the default and define your own.


From SpringBoot docs:  

https://docs.spring.io/spring-boot/docs/current/reference/htmlsingle/

	To switch off the default web application security configuration completely you can add a bean with @EnableWebSecurity (this does not disable the authentication manager configuration or Actuator’s security). To customize it you normally use external properties and beans of type WebSecurityConfigurerAdapter (e.g. to add form-based login).

	If you add @EnableWebSecurity and also disable Actuator security, you will get the default form-based login for the entire application unless you add a custom WebSecurityConfigurerAdapter.

	If you define a @Configuration with @EnableWebSecurity anywhere in your application it will switch off the default webapp security settings in Spring Boot (but leave the Actuator’s security enabled). To tweak the defaults try setting properties in security.* (see SecurityProperties for details of available settings) and SECURITY section of Common application properties.




NOTE: on ManagementServerProperties
		-----------------------------

If you provide a @Configuration with 

	@Order(ManagementServerProperties.ACCESS_OVERRIDE_ORDER)

it WILL override the Default SpringBoot Security, but for the Management
endpoint ONLY!!!


	/**
	 * Management Endpoint Configuration.
	 */
	@Configuration
	@Order(ManagementServerProperties.ACCESS_OVERRIDE_ORDER)
	public class ManagementEndpointConfiguration extends WebSecurityConfigurerAdapter {

	  private static final Logger log = LoggerFactory.getLogger(ManagementEndpointConfiguration.class);

	  /* management.security.user.name */
	  @Value("${management.security.user.name}")
	  private String name;

	  /* management.security.user.password */
	  @Value("${management.security.user.password}")
	  @NestedConfigurationProperty
	  private String password;

	  @Override
	  protected void configure(AuthenticationManagerBuilder auth) throws Exception {

	    auth
	        .inMemoryAuthentication()
	        .withUser(name)
	        .password(password)
	        .roles("ACTUATOR");
	  }

	  @Override
	  protected void configure(HttpSecurity http) throws Exception {
	    http
	        .authorizeRequests()
	        .anyRequest()
	        .authenticated()
	        .and()
	        .httpBasic();
	  }
	}



================================================================================

	Ordering WebSecurity and ResourceServer ConfigurerAdapters with SB 1.5
	**********************************************************************

to provide a mixed OAuth and BasicAuth security model.


Here is the configuration that orders 
-------------------------------------
1. actuator endpoint - BasicOauth
2. any other endpoint - OAuth
3. option to layer another WebSecurityConfigurerAdapter on top of the first two


BaseSecurityConfiguration.java
------------------------------


import java.io.IOException;
import java.util.Map;
import javax.servlet.http.HttpServletResponse;
import org.jasypt.encryption.StringEncryptor;
import org.jasypt.encryption.pbe.PooledPBEStringEncryptor;
import org.jasypt.encryption.pbe.config.EnvironmentPBEConfig;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.beans.factory.annotation.Value;
import org.springframework.boot.autoconfigure.security.oauth2.resource.JwtAccessTokenConverterConfigurer;
import org.springframework.context.annotation.Bean;
import org.springframework.context.annotation.Configuration;
import org.springframework.context.support.PropertySourcesPlaceholderConfigurer;
import org.springframework.core.annotation.Order;
import org.springframework.security.config.annotation.method.configuration.EnableGlobalMethodSecurity;
import org.springframework.security.config.annotation.web.builders.HttpSecurity;
import org.springframework.security.config.annotation.web.configuration.EnableWebSecurity;
import org.springframework.security.config.annotation.web.configuration.WebSecurityConfigurerAdapter;
import org.springframework.security.config.http.SessionCreationPolicy;
import org.springframework.security.core.userdetails.User;
import org.springframework.security.core.userdetails.UserDetailsService;
import org.springframework.security.oauth2.config.annotation.web.configuration.EnableResourceServer;
import org.springframework.security.oauth2.config.annotation.web.configuration.ResourceServerConfigurerAdapter;
import org.springframework.security.oauth2.config.annotation.web.configurers.ResourceServerSecurityConfigurer;
import org.springframework.security.oauth2.provider.OAuth2Authentication;
import org.springframework.security.oauth2.provider.token.DefaultAccessTokenConverter;
import org.springframework.security.oauth2.provider.token.DefaultTokenServices;
import org.springframework.security.oauth2.provider.token.ResourceServerTokenServices;
import org.springframework.security.oauth2.provider.token.TokenStore;
import org.springframework.security.oauth2.provider.token.store.JwtAccessTokenConverter;
import org.springframework.security.oauth2.provider.token.store.JwtTokenStore;
import org.springframework.security.provisioning.InMemoryUserDetailsManager;
import org.springframework.security.web.AuthenticationEntryPoint;
import org.springframework.security.web.authentication.www.BasicAuthenticationEntryPoint;

/**
 * Provides overall Security configuration for a typical SpringBoot
 * microservice implementing the following:
 * 1. the management endpoint is securing with  Basic Auth.
 * 2. application endpoint resources are secured with OAuth2/JWT-based authentication.
 */
@Configuration
@EnableWebSecurity
public class BaseSecurityConfiguration {

  private static final Logger log = LoggerFactory.getLogger(BaseSecurityConfiguration.class);

  public static final String ACTUATOR_SECURITY_ROLE = "ACTUATOR";


  /* =================  Management Endpoint Security ==================== */

  private String actuatorUserRole;
  /* management.security.user.name */
  @Value("${management.security.user.name}")
  private String actuatorUserName;
  /* management.security.user.password */
  @Value("${management.security.user.password}")
  private String actuatorUserPassword;

  /**
   * Actuator Security Config.
   * Important: this configuration load order is higher than the default of 100,
   * and is also higher than the Resource Server Config with the wild card pattern
   * matching.  This order allows us to match any actuator requests first and
   * apply system user basic auth to those requests.
   * For all other requests a higher order Resource Server configuration with its
   * wild card pattern matching will pick up all other requests.
   * The reason the order number is not 0 or 1 is to leave room for projects to create
   * higher order adapters if needed.
   */
  @Order(1)
  @Configuration
  public static class ActuatorSecurityConfiguration extends WebSecurityConfigurerAdapter {

    @Bean
    AuthenticationEntryPoint authenticationEntryPoint() {
      BasicAuthenticationEntryPoint entryPoint = new BasicAuthenticationEntryPoint();
      entryPoint.setRealmName("actuator realm");
      return entryPoint;
    }

    @Override
    protected void configure(HttpSecurity http) throws Exception {
      //@formatter:off
      http
          .antMatcher("/actuator/**")
          .authorizeRequests()
          .anyRequest().hasRole(ACTUATOR_SECURITY_ROLE)
          .and()
          .httpBasic()
          .authenticationEntryPoint(authenticationEntryPoint());
      //@formatter:on
    }
  }


  /**
   * User Details Service.
   *
   * @return UserDetailsService
   * @throws Exception e
   */
  @Bean
  public UserDetailsService userDetailsService() throws Exception {
    InMemoryUserDetailsManager manager = new InMemoryUserDetailsManager();

    // actuator authorized user
    manager.createUser(
        User
            .withUsername(actuatorUserName)
            .password(actuatorUserPassword)
            .roles(ACTUATOR_SECURITY_ROLE)
            .build()
    );

    return manager;
  }


  /* =================  Application Endpoint Security ==================== */

  @Value("${oauth.signingKey}")
  private String signingKey;

  /**
   * JWT token converter allows us to apply our signing key to enable token validation.
   * @return JwtAccessTokenConverter token converter
   */
  @Bean
  public JwtAccessTokenConverter accessTokenConverter() {
    JwtAccessTokenConverter converter = new JwtAccessTokenConverter();
    converter.setSigningKey(signingKey);
    converter.setAccessTokenConverter(new SfgSecurityConfiguration.JwtConverter());
    return converter;
  }

  /**
   * Token store with our JWT token converter.
   * @return TokenStore
   */
  @Bean
  public TokenStore tokenStore() {
    return new JwtTokenStore(accessTokenConverter());
  }

  /**
   * Resource Server Tokens Services with our TokenStore injected.
   * @return ResourceServerTokenServices
   */
  @Bean
  public ResourceServerTokenServices tokenServices() {
    DefaultTokenServices defaultTokenServices = new DefaultTokenServices();
    defaultTokenServices.setTokenStore(tokenStore());
    defaultTokenServices.setSupportRefreshToken(true);
    return defaultTokenServices;
  }

  /**
   * JWT Converter whose primary purpose is to copy JWT content into
   * OAuth2Authentication enabling access to JWT claims and other details.
   */
  public static class JwtConverter
      extends DefaultAccessTokenConverter
      implements JwtAccessTokenConverterConfigurer {

    @Override
    public void configure(JwtAccessTokenConverter converter) {
      converter.setAccessTokenConverter(this);
    }

    @Override
    public OAuth2Authentication extractAuthentication(Map<String, ?> map) {
      OAuth2Authentication auth = super.extractAuthentication(map);
      auth.setDetails(map); // copy JWT content into Authentication
      return auth;
    }
  }

  @Configuration
  @EnableResourceServer
  @EnableGlobalMethodSecurity(prePostEnabled = true)
  public static class OAuthResourceServerConfiguration extends ResourceServerConfigurerAdapter {

    @Value("${oauth.resourceId}")
    private String resourceId;

    @Autowired
    private TokenStore tokenStore;

    @Autowired
    private JwtAccessTokenConverter accessTokenConverter;

    @Autowired
    private ResourceServerTokenServices tokenServices;

    @Override
    public void configure(HttpSecurity http) throws Exception {
      http
          .antMatcher("/**")
          .authorizeRequests()
          .anyRequest().authenticated()
          .and()
          .sessionManagement()
          .sessionCreationPolicy(SessionCreationPolicy.STATELESS)
          .and()
          .csrf().disable()
          .exceptionHandling()
          .authenticationEntryPoint(
              (request, response, exception)
                  -> response.sendError(HttpServletResponse.SC_UNAUTHORIZED));
    }

    @Override
    public void configure(ResourceServerSecurityConfigurer resources) throws Exception {
      resources.tokenServices(tokenServices);
      // resources.resourceId(null);  // needed if tokens do not contain resourceId
      resources.resourceId(resourceId);  // needed if tokens contain resourceId
    }

  }

  /* =================  Enable Encrypted Properties ==================== */

  @Value("${jasypt.encryptor.password}")
  private String jasyptEncryptorPassword;

  /**
   * Bean for decrypting encrypted password. Password encryption/decryption uses a master password
   * that is stored as environment variable.
   */
  @Bean(name = "jasyptStringEncryptor")
  public StringEncryptor stringEncryptor() throws IOException {
    PooledPBEStringEncryptor encryptor = new PooledPBEStringEncryptor();
    EnvironmentPBEConfig config = new EnvironmentPBEConfig();
    encryptor.setConfig(config);
    config.setPassword(jasyptEncryptorPassword);
    config.setAlgorithm("PBEWithMD5AndDES");
    config.setKeyObtentionIterations("1000");
    config.setPoolSize("1");
    config.setProviderName("SunJCE");
    config.setSaltGeneratorClassName("org.jasypt.salt.RandomSaltGenerator");
    return encryptor;
  }

  /* =================  Enable Property Placeholders ==================== */

  /**
   * PropertySourcesPlaceholderConfigurer resolves ${...} placeholders within bean definition
   * property values.
   */
  @Bean
  public static PropertySourcesPlaceholderConfigurer propertySourcesPlaceholderConfigurer() {
    PropertySourcesPlaceholderConfigurer prop = new PropertySourcesPlaceholderConfigurer();
    prop.setIgnoreUnresolvablePlaceholders(true);
    return prop;
  }

}


Layer another WebSecurityConfigurerAdapter on top of actuator and OAuth resources
-------------------------------------------------------------

using Ordered.HIGHEST_PRECEDENCE


HelloWorldWebSecurityConfiguration.java
---------------------------------------

import org.springframework.context.annotation.Configuration;
import org.springframework.core.Ordered;
import org.springframework.core.annotation.Order;
import org.springframework.security.config.annotation.web.builders.HttpSecurity;
import org.springframework.security.config.annotation.web.configuration.WebSecurityConfigurerAdapter;

/**
 * Tests project team security override.
 */
@Order(Ordered.HIGHEST_PRECEDENCE)
@Configuration
public class HelloWorldWebSecurityConfiguration extends WebSecurityConfigurerAdapter {

  @Override
  protected void configure(HttpSecurity http) throws Exception {
    http
        .antMatcher("/helloworld/**")
        .authorizeRequests()
        .anyRequest()
        .permitAll();
  }
}


supporting cast, providing JwtAuthenticationContext
--------------------------------------------------------

This provides access to the JWT content at the REST resource/controller level:


SomeResourceController.java
---------------------------

import com.standard.cis.domain.DraftClaim;
import com.standard.cis.security.JwtAuthenticationContextFactory.JwtAuthenticationContext;
import com.standard.cis.service.DraftClaimsService;
import java.util.List;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.security.access.prepost.PreAuthorize;
import org.springframework.web.bind.annotation.CrossOrigin;
import org.springframework.web.bind.annotation.RequestMapping;
import org.springframework.web.bind.annotation.RequestMethod;
import org.springframework.web.bind.annotation.RestController;

/**
 * Exposes Draft Claim REST API.
 */
@RestController
@CrossOrigin
public class SomeResourceController {

  private static final Logger log = LoggerFactory.getLogger(SomeResourceController.class);

  @Autowired
  private JwtAuthenticationContext jwtAuthenticationContext;


  /**
   * draft claims REST resource.
   *
   */
  @RequestMapping(value = "/some-stuff", method = RequestMethod.GET)
  @PreAuthorize("hasAuthority('STANDARD_USER')")
  public List<Stuff> someStuff() {

    log.info("JWT username: {}", jwtAuthenticationContext.getUsername());
    log.info("JWT audience: {}", jwtAuthenticationContext.getAudience());
    log.info("JWT scopes: {}", jwtAuthenticationContext.getScopes());
    log.info("JWT expires: {}", jwtAuthenticationContext.getExpiresTimestamp());
    log.info("JWT authorities: {}", jwtAuthenticationContext.getAuthorities());
    log.info("JWT JTI: {}", jwtAuthenticationContext.getJti());
    log.info("JWT client ID: {}", jwtAuthenticationContext.getClientId());

    return stuff;
  }
}





================================================================================

	Formatting Java Time with SpringBoot using Jackson
	**************************************************

https://touk.pl/blog/2016/02/12/formatting-java-time-with-spring-boot-using-json/

add 

    <dependency>
      <groupId>com.fasterxml.jackson.datatype</groupId>
      <artifactId>jackson-datatype-jsr310</artifactId>
      <version>2.9.2</version>
    </dependency>

appliation.yml:

	spring.jackson.serialization.write_dates_as_timestamps: false


Custom formatting

	@JsonFormat(pattern = "dd::MM::yyyy")
	private final LocalDate localDate;

	@JsonFormat(pattern = "KK:mm a")
	private final LocalTime localTime;

now you get

{  
   "version":2,
   "localDate":"01::01::2016",
   "localTime":"10:24 AM",
   "localDateTime":"2016-01-01T10:24",
   "zonedDateTime":"2016-01-01T10:24:00+01:00"
}

================================================================================

	Jetty instead of Tomcat
	***********************

		<dependency>
			<groupId>org.springframework.boot</groupId>
			<artifactId>spring-boot-starter-web</artifactId>
			<exclusions>
				<exclusion>
					<groupId>org.springframework.boot</groupId>
					<artifactId>spring-boot-starter-tomcat</artifactId>
				</exclusion>
			</exclusions>
		</dependency>

		<dependency>
			<groupId>org.springframework.boot</groupId>
			<artifactId>spring-boot-starter-jetty</artifactId>
		</dependency>


================================================================================

	Typesafe configuration properties
	*********************************

https://docs.spring.io/spring-boot/docs/1.2.0.RELEASE/reference/htmlsingle/#boot-features-external-config-typesafe-configuration-properties


	Using the @Value("${property}") annotation to inject configuration properties can sometimes be cumbersome, especially if you are working with multiple properties or your data is hierarchical in nature. Spring Boot provides an alternative method of working with properties that allows strongly typed beans to govern and validate the configuration of your application.

	When the @EnableConfigurationProperties annotation is applied to your @Configuration, any beans annotated with @ConfigurationProperties will be automatically configured from the Environment properties. This style of configuration works particularly well with the SpringApplication external YAML configuration.

# application.yml

oauth:
    signingKey: ASDGA$%ADFDASFSDFAG


Option 1:  @Component/@ConfigurationProperties class + @Autowired
Option 2:  @ConfigurationProperties class + @EnableConfigurationProperties(class) + @Autowired


Option 1: @Component/@ConfigurationProperties class + @Autowired
--------------------------------------------------------------------------------

1. Create a @Component annotated with @ConfigurationProperties

	@Component
	@ConfigurationProperties(prefix = "oauth")
	public class OAuthProperties {

	  private String signingKey;

	  public String getSigningKey() {
	    return signingKey;
	  }

	  public void setSigningKey(String signingKey) {
	    this.signingKey = signingKey;
	  }

	}

2. Create a @Configuration and @Autowire

	@Configuration
	public class JwtConfiguration {

	  @Autowired
	  private OAuthProperties oAuthProperties;

	  . . .
	}


Option 2: @ConfigurationProperties class + @EnableConfigurationProperties(class) + @Autowired
--------------------------------------------------------------------------------

1. Create a class with @ConfigurationProperties

	@ConfigurationProperties(prefix = "oauth")
	public class OAuthProperties {

	  private String signingKey;

	  public String getSigningKey() {
	    return signingKey;
	  }

	  public void setSigningKey(String signingKey) {
	    this.signingKey = signingKey;
	  }

	}

2. Create a @Configuration class and @EnableConfigurationProperties(OAuthProperties.class)

	@Configuration
	@EnableConfigurationProperties(OAuthProperties.class)
	public class JwtConfiguration {

	  @Autowired
	  private OAuthProperties oAuthProperties;

	  . . .

	}


================================================================================

	Maven resource filtering
	************************

If you are inheriting from the spring-boot-starter-parent POM, the default filter token of the maven-resources-plugins has been changed from ${*} to @ (i.e. @maven.token@ instead of ${maven.token}) to prevent conflicts with Spring-style placeholders. If you have enabled maven filtering for the application.properties directly, you may want to also change the default filter token to use other delimiters.

{
  "claims-intake-api.version" : "@project.version@",
  "build.timestamp" : "@timestamp@"
}

  <build>
    <resources>
      <!-- resource supporting version info -->
      <resource>
        <directory>src/main/resources</directory>
        <filtering>true</filtering>
        <includes>
          <include>${version.info.file}</include>
        </includes>
      </resource>
      <resource>
        <directory>src/main/resources</directory>
        <filtering>false</filtering>
        <excludes>
          <exclude>${version.info.file}</exclude>
        </excludes>
      </resource>
    <resources>


================================================================================

	Debugging Property Loading
	**************************

package com.standard.cis.configuration;

import com.standard.cis.security.OAuthProperties;
import java.util.Arrays;
import java.util.HashMap;
import java.util.Iterator;
import java.util.Map;
import java.util.Set;
import javax.annotation.PostConstruct;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.context.annotation.Configuration;
import org.springframework.core.env.AbstractEnvironment;
import org.springframework.core.env.Environment;
import org.springframework.core.env.MapPropertySource;
import org.springframework.core.env.PropertySource;


@Configuration
public class PropertiesLogger {
  private static final Logger log = LoggerFactory.getLogger(PropertiesLogger.class);


  @Autowired
  private Environment environment;

  @Autowired
  private OAuthProperties oAuthProperties;

  @PostConstruct
  public void printProperties() {

    log.info("**** ACTIVE PROFILES  ****");
    log.info(Arrays.toString(environment.getActiveProfiles()));

    log.info("**** APPLICATION PROPERTIES ****");
    Map<String, Object> propertyMap = getEnvironmentProperties();
    print(propertyMap);

    log.info("**** OAUTH PROPERTIES ****");
    log.info("resourceId: {}", oAuthProperties.getResourceId());
    log.info("signingKey: {}", oAuthProperties.getSigningKey());

  }

  private Map<String, Object> getEnvironmentProperties() {
    Map<String, Object> map = new HashMap<>();
    for(Iterator it = ((AbstractEnvironment) environment).getPropertySources().iterator(); it.hasNext(); ) {
      PropertySource propertySource = (PropertySource) it.next();
      if (propertySource instanceof MapPropertySource) {
        map.putAll(((MapPropertySource) propertySource).getSource());
      }
    }
    return map;
  }

  private void print(Set<String> properties) {
    for (String propertyName : properties) {
      log.info("{}={}", propertyName, environment.getProperty(propertyName));
    }
  }

  private void print(Map<String, Object> propertyMap) {
    for (Map.Entry<String, Object> entry : propertyMap.entrySet()) {
      log.info("{} : {}", entry.getKey(), entry.getValue());
    }
  }

}


================================================================================

	Handlers
	********
http://anilkc.me/spring-boot-application-spring-security-custom-handlers/


Custom Login Success Handler
-------------------------------

	onAuthenticationSuccess() method is invoked only when the authentication is 
	successful.

@Component
public class CustomLoginSuccessfulHandler implements AuthenticationSuccessHandler {

  @Override
  public void onAuthenticationSuccess(HttpServletRequest request, HttpServletResponse response, Authentication authentication)
      throws IOException, ServletException {

    response.setStatus(HttpStatus.OK.value());
    response.setContentType(MediaType.APPLICATION_JSON_VALUE);
    response.setContentType("application/json");
    response.setCharacterEncoding("UTF-8");
    JSONObject jsonResponse = new JSONObject();
    jsonResponse.put("message", "Login Successful");
    response.getWriter().write(jsonResponse.toString());
  }

}

	this returns JSON object in response.


Custom login failure handler
-------------------------------

	This method is invoked when the login fails. On failure, this method writes proper message in the response object. We are returning HTTP status 400 in case of failed authentication.

@Component
public class CustomLoginFailureHandler implements AuthenticationFailureHandler {

  @Override
  public void onAuthenticationFailure(HttpServletRequest request, HttpServletResponse response, AuthenticationException exception)
      throws IOException, ServletException {
    
    response.setStatus(HttpStatus.BAD_REQUEST.value());
    response.setContentType(MediaType.APPLICATION_JSON_VALUE);
    response.setCharacterEncoding("UTF-8");
    JSONObject jsonResponse = new JSONObject();
    jsonResponse.put("message", "Invalid Credentials");
    response.getWriter().write(jsonResponse.toString());
  }

}


Custom authentication entry point
------------------------------------

	This handler is invoked if the user tries to access the secured resource without authentication. 

	Please note, this handler avoids Spring Security to redirect to login page. If you want user to be redirected to login page when user is not authenticated and tries to access secured resources, redirect to your login page or your resource. You can avoid this AuthenticationEntryPoint all together to get Spring default login page. 

	The commence method just returns the 403 HTTP status when this handler is invoked.


@Component
public class CustomAuthenticationEntryPoint implements AuthenticationEntryPoint {


  @Override
  public void commence(HttpServletRequest request, HttpServletResponse response, AuthenticationException authException)
      throws IOException, ServletException {
    response.sendError(HttpStatus.FORBIDDEN.value(), HttpStatus.FORBIDDEN.toString());
  }

}

Custom Access Denied Handler
-------------------------------

	When the authenticated user with certain role attempts to access the resource which isn’t available for that user then in that case, this handler is invoked. 

	This handler implements AccessDeniedHandler which has handle method. I have implemented this method to return HTTP 403 status with custom message.

@Component
public class CustomAccessDeniedHandler implements AccessDeniedHandler {

  @Override
  public void handle(HttpServletRequest request, HttpServletResponse response, AccessDeniedException accessDeniedException)
      throws IOException, ServletException {
    response.setStatus(HttpStatus.FORBIDDEN.value());
    response.setContentType(MediaType.APPLICATION_JSON_VALUE);
    response.setCharacterEncoding("UTF-8");
    JSONObject jsonResponse = new JSONObject();
    jsonResponse.put("message", "Access Denied");
    response.getWriter().write(jsonResponse.toString());
  }

}

Logout successful handler
-----------------------------

this handler returns logout successful message. This handler is invoked when the logout process is successful.

@Component
public class CustomLogoutSuccessfulHandler implements LogoutSuccessHandler {

  @Override
  public void onLogoutSuccess(HttpServletRequest request, HttpServletResponse response, Authentication authentication)
      throws IOException, ServletException {

    response.setStatus(HttpStatus.OK.value());
    response.setContentType(MediaType.APPLICATION_JSON_VALUE);
    response.setCharacterEncoding("UTF-8");
    JSONObject jsonResponse = new JSONObject();
    jsonResponse.put("message", "Logout Successful");
    response.getWriter().write(jsonResponse.toString());
  }

}

WebSecurityConfig
--------------------------------------

@Configuration
@EnableWebSecurity
public class WebSecurityConfig extends WebSecurityConfigurerAdapter {


  @Autowired
  private CustomLoginSuccessfulHandler loginSuccessfulHandler;

  @Autowired
  private CustomLoginFailureHandler loginFailureHandler;

  @Autowired
  private CustomLogoutSuccessfulHandler logoutSuccessfulHandler;

  @Autowired
  private CustomAccessDeniedHandler customAccessDeniedHandler;

  @Autowired
  private CustomAuthenticationEntryPoint customAuthenticationEntryPoint;

  @Bean
  @Override
  public AuthenticationManager authenticationManagerBean() throws Exception {
    return super.authenticationManagerBean();
  }

  @Override
  protected void configure(AuthenticationManagerBuilder auth) throws Exception {
  //@formatter:off
    auth.inMemoryAuthentication()
                .withUser("user").password("password").roles("USER")
                .and()
                .withUser("admin").password("password").roles("ADMIN");
  // @formatter:on

  }

  @Override
  protected void configure(HttpSecurity http) throws Exception {

  //@formatter:off
      http
      .csrf().disable()
          .formLogin()
              .loginProcessingUrl("/auth/login")
              .successHandler(loginSuccessfulHandler)
              .failureHandler(loginFailureHandler)
          .and()
              .logout()
              .logoutUrl("/auth/logout")
              .logoutSuccessHandler(logoutSuccessfulHandler)
          .and()
            .authorizeRequests()
            .antMatchers("/auth/login").permitAll()
            .antMatchers("/secure/admin").access("hasRole('ADMIN')")
            .anyRequest().authenticated()
           .and()
             .exceptionHandling().accessDeniedHandler(customAccessDeniedHandler)
             .authenticationEntryPoint(customAuthenticationEntryPoint)
          .and()
            .anonymous()
              .disable();
  // @formatter:on
  }
  
}

================================================================================

	Import @Configurations from library
	***********************************

some library
---------------

	@Configuration // allows to import this class
	@ComponentScan // Scan for beans and other configuration classes
	public class SomeLibrary {

	    // no main needed here
	
	}

app using the library
---------------------

	@SpringBootApplication
	@Import(SomeLibrary.class) // import the library
	public class OtherApplication {

	    // just put your standard main in this class
	
	}


================================================================================

