
	@@@@@@@@@@@@@@@@@@@

		SpringBoot

	@@@@@@@@@@@@@@@@@@@

Resources

multiple authentication mechanisms in a single app using java config
https://stackoverflow.com/questions/25794680/multiple-authentication-mechanisms-in-a-single-app-using-java-config

multiple security entry points
http://www.baeldung.com/spring-security-multiple-entry-points
https://github.com/eugenp/tutorials/blob/master/spring-security-mvc-boot/src/main/java/org/baeldung/multipleentrypoints/MultipleEntryPointsSecurityConfig.java

@Order
https://stackoverflow.com/questions/45529743/ordersecurityproperties-access-override-order-vs-managementserverproperties-a

Multiple HttpSecurity
https://docs.spring.io/spring-security/site/docs/current/reference/html/jc.html


================================================================================

  common application properties
  *****************************

https://docs.spring.io/spring-boot/docs/current/reference/html/common-application-properties.html


================================================================================

	SpringBoot 2.0 M4 Security Changes
	**********************************

https://spring.io/blog/2017/09/15/security-changes-in-spring-boot-2-0-m4

Until Spring Boot 1.x, the default auto-configuration secured all of the application endpoints using basic authentication. If actuator was on the classpath, there was a separate security configuration that applied to the actuator endpoints. The way these two auto-configurations would turn on and off was completely independent. Because of this, users wanting to provide custom security found themselves fighting ordering issues with WebSecurityConfigurerAdapters.

Additionally, for actuator endpoints, the effects of the management.security.enabled flag based on whether Spring Security was on the classpath or not was quite confusing.

There were a number of properties under security.* and management.security.* that were applicable only to the auto-configuration provided by Spring Boot. For example, if security.basic.enabled was set to false, setting security.sessions would have absolutely no effect and this turned out to be quite misleading.

	Improvements in 2.0
	-------------------

Default Configuration




================================================================================

	Structure Spring Boot application
	*********************************

Locate your main application class in root package above all other classes.

@EnableAutoConfiguration is often placed in your main class, and is implicitly
defines a base "search package" for certain items.
E.g. if you're wiring a JPA application, the package of the @EnableAutoConfiguration class will be used to search for @Entity items. 

Using root package allows the @ComponentScan annotation to be used without 
needed to specify a "basePackage" attribute.

Typical layout:

com
 +- example
     +- myproject
         +- Application.java //@SpringBootApplication
         |
         +- domain
         |   +- Customer.java
         |   +- CustomerRepository.java
         |
         +- service
         |   +- CustomerService.java
         |
         +- web
             +- CustomerController.java


package com.example.myproject;

@Configuration
@EnableAutoConfiguration
@ComponentScan
public class Application {

    public static void main(String[] args) {
        SpringApplication.run(Application.class, args);
    }

}


================================================================================

	SpringBoot Security
	*******************


***************************************
* Keys to different security schemes applied to different parts of your app
* 
* 1. create separate Spring security @Configurations where each one will 
*    configure just one authentication mechanism
*
* 2. each configuration should  specify the URIs it covers
*
* 3. @Configurations need to be ordered.
*
* 4. The @Configurations that need to be ordered are the ones extending
*    ResourceServerConfigurerAdatper and WebSecurityConfigurerAdapter.
*    The classes containing these `protected static classes` are not really
*    @Configurations themselves
* 5. The @Configuration without the @Order annotation is considered last -
*    this is your fallback or fallthru or .. 
*    This could be your resource server config with "/**" pattern matching while
*    higher order configurations could apply alt. authn mechanisms to specific
*    paths like "/actuator/**"
* 6. Use `http.antMatcher(...)` which can be confused with 
*        `http.authorizeRequests().antMatchers(...)` but it's different.



If Spring Security is on the classpath then web applications will be secure by default with ‘basic’ authentication on all HTTP endpoints. 

To add method-level security to a web application you can also add @EnableGlobalMethodSecurity with your desired settings.


	Default SpringBoot Security
	***************************

The default AuthenticationManager has a single user (‘user’ username and random password, printed at INFO level when the application starts up):

	Using default security password: 78fa095d-3f4c-48b1-ad50-e24c31d5cf35


	Order
	*****

Default Security Configuration Order: 100

if you want to apply a resource server filter chain for '/oauth/***', 
you need to specify order as follows:

(1) : [DEFAULT] (= 100)
(2) : 99 or under (e.g: security.oauth2.resource.filter-order=99)


	Override Default SpringBoot Security
	************************************

You can provide a WebSecurityconfigurerAdapter with 

  @Override
  public void configure(AuthenticationManagerBuilder auth) throws Exception {
  	. . .
  }

  @Override
  public void configure(HttpSecurity http) throws Exception {
  	. . .
  }

doesn't matter! - Default SrpingBoot Security will still be in effect.

You need to annotate your WebSecurityConfigurerAdapter with @EnableWebSecurity


	@Order(SecurityProperties.ACCESS_OVERRIDE_ORDER)
	@Configuration
	@EnableWebSecurity
	public class ApplicationEndpointSecurity extends WebSecurityConfigurerAdapter {

	  @Override
	  public void configure(AuthenticationManagerBuilder auth) throws Exception {
	  	. . .
	  }

	  @Override
	  public void configure(HttpSecurity http) throws Exception {
	  	. . .
	  }

	}


and now those overrides will take effect.

	Purpose of @EnableWebSecurity

Apparently to turn off the default and define your own.


From SpringBoot docs:  

https://docs.spring.io/spring-boot/docs/current/reference/htmlsingle/

	To switch off the default web application security configuration completely you can add a bean with @EnableWebSecurity (this does not disable the authentication manager configuration or Actuator’s security). To customize it you normally use external properties and beans of type WebSecurityConfigurerAdapter (e.g. to add form-based login).

	If you add @EnableWebSecurity and also disable Actuator security, you will get the default form-based login for the entire application unless you add a custom WebSecurityConfigurerAdapter.

	If you define a @Configuration with @EnableWebSecurity anywhere in your application it will switch off the default webapp security settings in Spring Boot (but leave the Actuator’s security enabled). To tweak the defaults try setting properties in security.* (see SecurityProperties for details of available settings) and SECURITY section of Common application properties.




NOTE: on ManagementServerProperties
		-----------------------------

If you provide a @Configuration with 

	@Order(ManagementServerProperties.ACCESS_OVERRIDE_ORDER)

it WILL override the Default SpringBoot Security, but for the Management
endpoint ONLY!!!


	/**
	 * Management Endpoint Configuration.
	 */
	@Configuration
	@Order(ManagementServerProperties.ACCESS_OVERRIDE_ORDER)
	public class ManagementEndpointConfiguration extends WebSecurityConfigurerAdapter {

	  private static final Logger log = LoggerFactory.getLogger(ManagementEndpointConfiguration.class);

	  /* management.security.user.name */
	  @Value("${management.security.user.name}")
	  private String name;

	  /* management.security.user.password */
	  @Value("${management.security.user.password}")
	  @NestedConfigurationProperty
	  private String password;

	  @Override
	  protected void configure(AuthenticationManagerBuilder auth) throws Exception {

	    auth
	        .inMemoryAuthentication()
	        .withUser(name)
	        .password(password)
	        .roles("ACTUATOR");
	  }

	  @Override
	  protected void configure(HttpSecurity http) throws Exception {
	    http
	        .authorizeRequests()
	        .anyRequest()
	        .authenticated()
	        .and()
	        .httpBasic();
	  }
	}



================================================================================

	Ordering WebSecurity and ResourceServer ConfigurerAdapters with SB 1.5
	**********************************************************************

to provide a mixed OAuth and BasicAuth security model.


Here is the configuration that orders 
-------------------------------------
1. actuator endpoint - BasicOauth
2. any other endpoint - OAuth
3. option to layer another WebSecurityConfigurerAdapter on top of the first two


BaseSecurityConfiguration.java
------------------------------


import java.io.IOException;
import java.util.Map;
import javax.servlet.http.HttpServletResponse;
import org.jasypt.encryption.StringEncryptor;
import org.jasypt.encryption.pbe.PooledPBEStringEncryptor;
import org.jasypt.encryption.pbe.config.EnvironmentPBEConfig;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.beans.factory.annotation.Value;
import org.springframework.boot.autoconfigure.security.oauth2.resource.JwtAccessTokenConverterConfigurer;
import org.springframework.context.annotation.Bean;
import org.springframework.context.annotation.Configuration;
import org.springframework.context.support.PropertySourcesPlaceholderConfigurer;
import org.springframework.core.annotation.Order;
import org.springframework.security.config.annotation.method.configuration.EnableGlobalMethodSecurity;
import org.springframework.security.config.annotation.web.builders.HttpSecurity;
import org.springframework.security.config.annotation.web.configuration.EnableWebSecurity;
import org.springframework.security.config.annotation.web.configuration.WebSecurityConfigurerAdapter;
import org.springframework.security.config.http.SessionCreationPolicy;
import org.springframework.security.core.userdetails.User;
import org.springframework.security.core.userdetails.UserDetailsService;
import org.springframework.security.oauth2.config.annotation.web.configuration.EnableResourceServer;
import org.springframework.security.oauth2.config.annotation.web.configuration.ResourceServerConfigurerAdapter;
import org.springframework.security.oauth2.config.annotation.web.configurers.ResourceServerSecurityConfigurer;
import org.springframework.security.oauth2.provider.OAuth2Authentication;
import org.springframework.security.oauth2.provider.token.DefaultAccessTokenConverter;
import org.springframework.security.oauth2.provider.token.DefaultTokenServices;
import org.springframework.security.oauth2.provider.token.ResourceServerTokenServices;
import org.springframework.security.oauth2.provider.token.TokenStore;
import org.springframework.security.oauth2.provider.token.store.JwtAccessTokenConverter;
import org.springframework.security.oauth2.provider.token.store.JwtTokenStore;
import org.springframework.security.provisioning.InMemoryUserDetailsManager;
import org.springframework.security.web.AuthenticationEntryPoint;
import org.springframework.security.web.authentication.www.BasicAuthenticationEntryPoint;

/**
 * Provides overall Security configuration for a typical SpringBoot
 * microservice implementing the following:
 * 1. the management endpoint is securing with  Basic Auth.
 * 2. application endpoint resources are secured with OAuth2/JWT-based authentication.
 */
@Configuration
@EnableWebSecurity
public class BaseSecurityConfiguration {

  private static final Logger log = LoggerFactory.getLogger(BaseSecurityConfiguration.class);

  public static final String ACTUATOR_SECURITY_ROLE = "ACTUATOR";


  /* =================  Management Endpoint Security ==================== */

  private String actuatorUserRole;
  /* management.security.user.name */
  @Value("${management.security.user.name}")
  private String actuatorUserName;
  /* management.security.user.password */
  @Value("${management.security.user.password}")
  private String actuatorUserPassword;

  /**
   * Actuator Security Config.
   * Important: this configuration load order is higher than the default of 100,
   * and is also higher than the Resource Server Config with the wild card pattern
   * matching.  This order allows us to match any actuator requests first and
   * apply system user basic auth to those requests.
   * For all other requests a higher order Resource Server configuration with its
   * wild card pattern matching will pick up all other requests.
   * The reason the order number is not 0 or 1 is to leave room for projects to create
   * higher order adapters if needed.
   */
  @Order(1)
  @Configuration
  public static class ActuatorSecurityConfiguration extends WebSecurityConfigurerAdapter {

    @Bean
    AuthenticationEntryPoint authenticationEntryPoint() {
      BasicAuthenticationEntryPoint entryPoint = new BasicAuthenticationEntryPoint();
      entryPoint.setRealmName("actuator realm");
      return entryPoint;
    }

    @Override
    protected void configure(HttpSecurity http) throws Exception {
      //@formatter:off
      http
          .antMatcher("/actuator/**")
          .authorizeRequests()
          .anyRequest().hasRole(ACTUATOR_SECURITY_ROLE)
          .and()
          .httpBasic()
          .authenticationEntryPoint(authenticationEntryPoint());
      //@formatter:on
    }
  }


  /**
   * User Details Service.
   *
   * @return UserDetailsService
   * @throws Exception e
   */
  @Bean
  public UserDetailsService userDetailsService() throws Exception {
    InMemoryUserDetailsManager manager = new InMemoryUserDetailsManager();

    // actuator authorized user
    manager.createUser(
        User
            .withUsername(actuatorUserName)
            .password(actuatorUserPassword)
            .roles(ACTUATOR_SECURITY_ROLE)
            .build()
    );

    return manager;
  }


  /* =================  Application Endpoint Security ==================== */

  @Value("${oauth.signingKey}")
  private String signingKey;

  /**
   * JWT token converter allows us to apply our signing key to enable token validation.
   * @return JwtAccessTokenConverter token converter
   */
  @Bean
  public JwtAccessTokenConverter accessTokenConverter() {
    JwtAccessTokenConverter converter = new JwtAccessTokenConverter();
    converter.setSigningKey(signingKey);
    converter.setAccessTokenConverter(new SfgSecurityConfiguration.JwtConverter());
    return converter;
  }

  /**
   * Token store with our JWT token converter.
   * @return TokenStore
   */
  @Bean
  public TokenStore tokenStore() {
    return new JwtTokenStore(accessTokenConverter());
  }

  /**
   * Resource Server Tokens Services with our TokenStore injected.
   * @return ResourceServerTokenServices
   */
  @Bean
  public ResourceServerTokenServices tokenServices() {
    DefaultTokenServices defaultTokenServices = new DefaultTokenServices();
    defaultTokenServices.setTokenStore(tokenStore());
    defaultTokenServices.setSupportRefreshToken(true);
    return defaultTokenServices;
  }

  /**
   * JWT Converter whose primary purpose is to copy JWT content into
   * OAuth2Authentication enabling access to JWT claims and other details.
   */
  public static class JwtConverter
      extends DefaultAccessTokenConverter
      implements JwtAccessTokenConverterConfigurer {

    @Override
    public void configure(JwtAccessTokenConverter converter) {
      converter.setAccessTokenConverter(this);
    }

    @Override
    public OAuth2Authentication extractAuthentication(Map<String, ?> map) {
      OAuth2Authentication auth = super.extractAuthentication(map);
      auth.setDetails(map); // copy JWT content into Authentication
      return auth;
    }
  }

  @Configuration
  @EnableResourceServer
  @EnableGlobalMethodSecurity(prePostEnabled = true)
  public static class OAuthResourceServerConfiguration extends ResourceServerConfigurerAdapter {

    @Value("${oauth.resourceId}")
    private String resourceId;

    @Autowired
    private TokenStore tokenStore;

    @Autowired
    private JwtAccessTokenConverter accessTokenConverter;

    @Autowired
    private ResourceServerTokenServices tokenServices;

    @Override
    public void configure(HttpSecurity http) throws Exception {
      http
          .antMatcher("/**")
          .authorizeRequests()
          .anyRequest().authenticated()
          .and()
          .sessionManagement()
          .sessionCreationPolicy(SessionCreationPolicy.STATELESS)
          .and()
          .csrf().disable()
          .exceptionHandling()
          .authenticationEntryPoint(
              (request, response, exception)
                  -> response.sendError(HttpServletResponse.SC_UNAUTHORIZED));
    }

    @Override
    public void configure(ResourceServerSecurityConfigurer resources) throws Exception {
      resources.tokenServices(tokenServices);
      // resources.resourceId(null);  // needed if tokens do not contain resourceId
      resources.resourceId(resourceId);  // needed if tokens contain resourceId
    }

  }

  /* =================  Enable Encrypted Properties ==================== */

  @Value("${jasypt.encryptor.password}")
  private String jasyptEncryptorPassword;

  /**
   * Bean for decrypting encrypted password. Password encryption/decryption uses a master password
   * that is stored as environment variable.
   */
  @Bean(name = "jasyptStringEncryptor")
  public StringEncryptor stringEncryptor() throws IOException {
    PooledPBEStringEncryptor encryptor = new PooledPBEStringEncryptor();
    EnvironmentPBEConfig config = new EnvironmentPBEConfig();
    encryptor.setConfig(config);
    config.setPassword(jasyptEncryptorPassword);
    config.setAlgorithm("PBEWithMD5AndDES");
    config.setKeyObtentionIterations("1000");
    config.setPoolSize("1");
    config.setProviderName("SunJCE");
    config.setSaltGeneratorClassName("org.jasypt.salt.RandomSaltGenerator");
    return encryptor;
  }

  /* =================  Enable Property Placeholders ==================== */

  /**
   * PropertySourcesPlaceholderConfigurer resolves ${...} placeholders within bean definition
   * property values.
   */
  @Bean
  public static PropertySourcesPlaceholderConfigurer propertySourcesPlaceholderConfigurer() {
    PropertySourcesPlaceholderConfigurer prop = new PropertySourcesPlaceholderConfigurer();
    prop.setIgnoreUnresolvablePlaceholders(true);
    return prop;
  }

}


Layer another WebSecurityConfigurerAdapter on top of actuator and OAuth resources
-------------------------------------------------------------

using Ordered.HIGHEST_PRECEDENCE


HelloWorldWebSecurityConfiguration.java
---------------------------------------

import org.springframework.context.annotation.Configuration;
import org.springframework.core.Ordered;
import org.springframework.core.annotation.Order;
import org.springframework.security.config.annotation.web.builders.HttpSecurity;
import org.springframework.security.config.annotation.web.configuration.WebSecurityConfigurerAdapter;

/**
 * Tests project team security override.
 */
@Order(Ordered.HIGHEST_PRECEDENCE)
@Configuration
public class HelloWorldWebSecurityConfiguration extends WebSecurityConfigurerAdapter {

  @Override
  protected void configure(HttpSecurity http) throws Exception {
    http
        .antMatcher("/helloworld/**")
        .authorizeRequests()
        .anyRequest()
        .permitAll();
  }
}


supporting cast, providing JwtAuthenticationContext
--------------------------------------------------------

This provides access to the JWT content at the REST resource/controller level:


SomeResourceController.java
---------------------------

import com.standard.cis.domain.DraftClaim;
import com.standard.cis.security.JwtAuthenticationContextFactory.JwtAuthenticationContext;
import com.standard.cis.service.DraftClaimsService;
import java.util.List;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.security.access.prepost.PreAuthorize;
import org.springframework.web.bind.annotation.CrossOrigin;
import org.springframework.web.bind.annotation.RequestMapping;
import org.springframework.web.bind.annotation.RequestMethod;
import org.springframework.web.bind.annotation.RestController;

/**
 * Exposes Draft Claim REST API.
 */
@RestController
@CrossOrigin
public class SomeResourceController {

  private static final Logger log = LoggerFactory.getLogger(SomeResourceController.class);

  @Autowired
  private JwtAuthenticationContext jwtAuthenticationContext;


  /**
   * draft claims REST resource.
   *
   */
  @RequestMapping(value = "/some-stuff", method = RequestMethod.GET)
  @PreAuthorize("hasAuthority('STANDARD_USER')")
  public List<Stuff> someStuff() {

    log.info("JWT username: {}", jwtAuthenticationContext.getUsername());
    log.info("JWT audience: {}", jwtAuthenticationContext.getAudience());
    log.info("JWT scopes: {}", jwtAuthenticationContext.getScopes());
    log.info("JWT expires: {}", jwtAuthenticationContext.getExpiresTimestamp());
    log.info("JWT authorities: {}", jwtAuthenticationContext.getAuthorities());
    log.info("JWT JTI: {}", jwtAuthenticationContext.getJti());
    log.info("JWT client ID: {}", jwtAuthenticationContext.getClientId());

    return stuff;
  }
}





================================================================================

	Formatting Java Time with SpringBoot using Jackson
	**************************************************

https://touk.pl/blog/2016/02/12/formatting-java-time-with-spring-boot-using-json/

add 

    <dependency>
      <groupId>com.fasterxml.jackson.datatype</groupId>
      <artifactId>jackson-datatype-jsr310</artifactId>
      <version>2.9.2</version>
    </dependency>

appliation.yml:

	spring.jackson.serialization.write_dates_as_timestamps: false


Custom formatting

	@JsonFormat(pattern = "dd::MM::yyyy")
	private final LocalDate localDate;

	@JsonFormat(pattern = "KK:mm a")
	private final LocalTime localTime;

now you get

{  
   "version":2,
   "localDate":"01::01::2016",
   "localTime":"10:24 AM",
   "localDateTime":"2016-01-01T10:24",
   "zonedDateTime":"2016-01-01T10:24:00+01:00"
}

================================================================================

	Jetty instead of Tomcat
	***********************

		<dependency>
			<groupId>org.springframework.boot</groupId>
			<artifactId>spring-boot-starter-web</artifactId>
			<exclusions>
				<exclusion>
					<groupId>org.springframework.boot</groupId>
					<artifactId>spring-boot-starter-tomcat</artifactId>
				</exclusion>
			</exclusions>
		</dependency>

		<dependency>
			<groupId>org.springframework.boot</groupId>
			<artifactId>spring-boot-starter-jetty</artifactId>
		</dependency>


================================================================================
================================================================================

  Reading application properties in Spring
  ****************************************

http://www.appsdeveloperblog.com/reading-application-properties-spring-boot/

There are a few ways to read application properties from application.properties
or application.yml in SpringBoot.

1. using Environment object
2. using @Value annotation
3. using @ConfigurationProperties


1. Using Environment object
----------------------------------------  

@Autowired
private Environment env;

String keyValue = env.getProperty(key);

example:

app.title=Learning Spring Boot 
app.description=Working with properties file

  @RestController
  @RequestMapping("app")
  public class AppController {
   
   @Autowired
   private Environment env; // autowired Environment object
   
   @GetMapping("/property")
   public String getPropertyValue(@RequestParam("key") String key) {
    String returnValue = "No value";
    
    String keyValue = env.getProperty(key);  // read property 
    
    if( keyValue!= null && !keyValue.isEmpty()) {
     returnValue = keyValue;
    }
    return returnValue;
   }

  }


3. Reading properties with @ConfigurationProperties
-----------------------------------------------------

Create a POJO object where each class field matches the name of the key 
in a propeprty file.

properties:
-----------

  app.title=Learning Spring Boot 
  app.description=Working with properties file

property object class:
----------------------
  @Component
  @ConfigurationProperties("app")
  public class AppProperties {
   
   private String title;
   private String description;
   public String getTitle() {
    return title;
   }
   public void setTitle(String title) {
    this.title = title;
   }
   public String getDescription() {
    return description;
   }
   public void setDescription(String description) {
    this.description = description;
   }
   
  }

controller
-----------

  @RestController
  @RequestMapping("app")
  public class AppController {
   
   
   @Autowired
   AppProperties myAppProperties;  // injected properties object
   
   
   @GetMapping("/title")
   public String getAppTitle() {
    return myAppProperties.getTitle(); // read title from properties object
   }
   
   @GetMapping("/description")
   public String getAppDescription() {
    return myAppProperties.getDescription();
   }
   
  }


================================================================================

	Typesafe configuration properties
	*********************************

https://docs.spring.io/spring-boot/docs/1.2.0.RELEASE/reference/htmlsingle/#boot-features-external-config-typesafe-configuration-properties


	Using the @Value("${property}") annotation to inject configuration properties can sometimes be cumbersome, especially if you are working with multiple properties or your data is hierarchical in nature. Spring Boot provides an alternative method of working with properties that allows strongly typed beans to govern and validate the configuration of your application.

	When the @EnableConfigurationProperties annotation is applied to your @Configuration, any beans annotated with @ConfigurationProperties will be automatically configured from the Environment properties. This style of configuration works particularly well with the SpringApplication external YAML configuration.

# application.yml

oauth:
    signingKey: ASDGA$%ADFDASFSDFAG


Option 1:  @Component/@ConfigurationProperties class + @Autowired
Option 2:  @ConfigurationProperties class + @EnableConfigurationProperties(class) + @Autowired


Option 1: @Component/@ConfigurationProperties class + @Autowired
--------------------------------------------------------------------------------

1. Create a @Component annotated with @ConfigurationProperties

	@Component
	@ConfigurationProperties(prefix = "oauth")
	public class OAuthProperties {

	  private String signingKey;

	  public String getSigningKey() {
	    return signingKey;
	  }

	  public void setSigningKey(String signingKey) {
	    this.signingKey = signingKey;
	  }

	}

2. Create a @Configuration and @Autowire

	@Configuration
	public class JwtConfiguration {

	  @Autowired
	  private OAuthProperties oAuthProperties;

	  . . .
	}


Option 2: @ConfigurationProperties class + @EnableConfigurationProperties(class) + @Autowired
--------------------------------------------------------------------------------

1. Create a class with @ConfigurationProperties

	@ConfigurationProperties(prefix = "oauth")
	public class OAuthProperties {

	  private String signingKey;

	  public String getSigningKey() {
	    return signingKey;
	  }

	  public void setSigningKey(String signingKey) {
	    this.signingKey = signingKey;
	  }

	}

2. Create a @Configuration class and @EnableConfigurationProperties(OAuthProperties.class)

	@Configuration
	@EnableConfigurationProperties(OAuthProperties.class)
	public class JwtConfiguration {

	  @Autowired
	  private OAuthProperties oAuthProperties;

	  . . .

	}


================================================================================

	Maven resource filtering
	************************

If you are inheriting from the spring-boot-starter-parent POM, the default filter token of the maven-resources-plugins has been changed from ${*} to @ (i.e. @maven.token@ instead of ${maven.token}) to prevent conflicts with Spring-style placeholders. If you have enabled maven filtering for the application.properties directly, you may want to also change the default filter token to use other delimiters.

{
  "claims-intake-api.version" : "@project.version@",
  "build.timestamp" : "@timestamp@"
}

  <build>
    <resources>
      <!-- resource supporting version info -->
      <resource>
        <directory>src/main/resources</directory>
        <filtering>true</filtering>
        <includes>
          <include>${version.info.file}</include>
        </includes>
      </resource>
      <resource>
        <directory>src/main/resources</directory>
        <filtering>false</filtering>
        <excludes>
          <exclude>${version.info.file}</exclude>
        </excludes>
      </resource>
    <resources>


================================================================================
================================================================================

  Spring Boot Error Handling
  **************************

@ExceptionHandler
HandlerExceptionResolver

  Before Spring 3.2, the two main approaches to handling exceptions 
  in a Spring MVC application were:     
    HandlerExceptionResolver or 
    @ExceptionHandler annotation. 
  Both of these have some clear downsides.

  This annotation, if used on methods of controller classes, will serve as the entry point for handling exceptions thrown within this controller only. 


@ControllerAdvice

After 3.2 we now have the new @ControllerAdvice annotation to address the limitations of the previous two solutions.

================================================================================

  @ExceptionHandler 
  -----------------

This works at the @Controller level - define a method to handle exceptions, and
annotate that with @ExceptionHandler

  public class FooController {

    @ExceptionHandler( { CustomExceptionOne.class, CustomExceptionTwo.class })
    public void handleException() {
      // return 404
      ErrorDetails errorDetails = new ErrorDetails(new Date(), ex.getMessage(),
        request.getDescription(false));
      return new ResponseEntity<>(errorDetails, HttpStatus.NOT_FOUND);
    }

  }

This approach has a MAJOR DRAWBACK - the @ExceptionHandler annotated method
is ONLY active for that particular Controller, not globally for the entire
application.

This limitation is often worked around by having all Controllers extends a 
Base Controller class - however, this could be a problem where a Controller 
cannot be made to extend from a such a class.


================================================================================

  HandlerExceptionResolver
  -------------------------
https://www.baeldung.com/exception-handling-for-rest-with-spring


this will resolve ANY exception thrown by the application. 
It will also allow us to implement a uniform exception handling mechanism in our REST API.

Limitations:
 - no control over the body of the response.
 - it’s interacting with the low-level HtttpServletResponse and 
 - it fits into the old MVC model which uses ModelAndView – so there’s still room for improvement.


================================================================================

  @ControllerAdvice
  *****************

Spring 3.2 brings support for a global @ExceptionHandler with the new 
@ControllerAdvice annotation.

It is an "Advice" for multiple controllers, used to enable a single ExceptionHandler
to be applied to multiple controllers.  This way we can define, in just one place, 
how to treat such an exception and this handler will be called when the
exception is thrown from classes that are covered by this @ControllerAdvice.





--------------------------------------------------------------------------------

  selectors
  ---------

@ControllerAdvice(annotations ... )
@ControllerAdvice(assignableTypes ... )
@ControllerAdvice(annotations ... )

  annotations

The subset of controllers affected can be defined by using the following 

AdviceA.class
-------------
@ControllerAdvice(annotations = {UseAdviceA.class})
class AdviceA {

  @ExceptionHandler({SomeException.class})
  public ResponseEntity<String> handleSomeException(SomeException pe, HandlerMethod handlerMethod) {
    String value = handlerMethod.getMethod().getDeclaringClass().getAnnotation(UseAdviceA.class).myValue();
     //value will be ApiController
    return new ResponseEntity<>("SomeString", HttpStatus.BAD_REQUEST);
  }

}  

UseAdviceA.class
----------------
@Target({ElementType.TYPE})
@Retention(RetentionPolicy.RUNTIME)
public @interface UseAdviceA {
  public String myValue();
}  


enabled AdviceA on ApiController.class
---------------------------------------
@RestController
@UseAdviceA(myValue = "ApiController")
@RequestMapping("/myapi")
class ApiController {
 ...
}


  assignableTypes

@ControllerAdvice(assignableTypes = AController.class)
public class AControllerAdvice {
    @ModelAttribute
    public void addModelInformation(Model model){
         //controller specific model information for header and footer added here
    }
}





================================================================================

	Handlers
	********
http://anilkc.me/spring-boot-application-spring-security-custom-handlers/


Custom Login Success Handler
-------------------------------

	onAuthenticationSuccess() method is invoked only when the authentication is 
	successful.

@Component
public class CustomLoginSuccessfulHandler implements AuthenticationSuccessHandler {

  @Override
  public void onAuthenticationSuccess(HttpServletRequest request, HttpServletResponse response, Authentication authentication)
      throws IOException, ServletException {

    response.setStatus(HttpStatus.OK.value());
    response.setContentType(MediaType.APPLICATION_JSON_VALUE);
    response.setContentType("application/json");
    response.setCharacterEncoding("UTF-8");
    JSONObject jsonResponse = new JSONObject();
    jsonResponse.put("message", "Login Successful");
    response.getWriter().write(jsonResponse.toString());
  }

}

	this returns JSON object in response.


Custom login failure handler
-------------------------------

	This method is invoked when the login fails. On failure, this method writes proper message in the response object. We are returning HTTP status 400 in case of failed authentication.

@Component
public class CustomLoginFailureHandler implements AuthenticationFailureHandler {

  @Override
  public void onAuthenticationFailure(HttpServletRequest request, HttpServletResponse response, AuthenticationException exception)
      throws IOException, ServletException {
    
    response.setStatus(HttpStatus.BAD_REQUEST.value());
    response.setContentType(MediaType.APPLICATION_JSON_VALUE);
    response.setCharacterEncoding("UTF-8");
    JSONObject jsonResponse = new JSONObject();
    jsonResponse.put("message", "Invalid Credentials");
    response.getWriter().write(jsonResponse.toString());
  }

}


Custom authentication entry point
------------------------------------

	This handler is invoked if the user tries to access the secured resource without authentication. 

	Please note, this handler avoids Spring Security to redirect to login page. If you want user to be redirected to login page when user is not authenticated and tries to access secured resources, redirect to your login page or your resource. You can avoid this AuthenticationEntryPoint all together to get Spring default login page. 

	The commence method just returns the 403 HTTP status when this handler is invoked.


@Component
public class CustomAuthenticationEntryPoint implements AuthenticationEntryPoint {


  @Override
  public void commence(HttpServletRequest request, HttpServletResponse response, AuthenticationException authException)
      throws IOException, ServletException {
    response.sendError(HttpStatus.FORBIDDEN.value(), HttpStatus.FORBIDDEN.toString());
  }

}

Custom Access Denied Handler
-------------------------------

	When the authenticated user with certain role attempts to access the resource which isn’t available for that user then in that case, this handler is invoked. 

	This handler implements AccessDeniedHandler which has handle method. I have implemented this method to return HTTP 403 status with custom message.

@Component
public class CustomAccessDeniedHandler implements AccessDeniedHandler {

  @Override
  public void handle(HttpServletRequest request, HttpServletResponse response, AccessDeniedException accessDeniedException)
      throws IOException, ServletException {
    response.setStatus(HttpStatus.FORBIDDEN.value());
    response.setContentType(MediaType.APPLICATION_JSON_VALUE);
    response.setCharacterEncoding("UTF-8");
    JSONObject jsonResponse = new JSONObject();
    jsonResponse.put("message", "Access Denied");
    response.getWriter().write(jsonResponse.toString());
  }

}

Logout successful handler
-----------------------------

this handler returns logout successful message. This handler is invoked when the logout process is successful.

@Component
public class CustomLogoutSuccessfulHandler implements LogoutSuccessHandler {

  @Override
  public void onLogoutSuccess(HttpServletRequest request, HttpServletResponse response, Authentication authentication)
      throws IOException, ServletException {

    response.setStatus(HttpStatus.OK.value());
    response.setContentType(MediaType.APPLICATION_JSON_VALUE);
    response.setCharacterEncoding("UTF-8");
    JSONObject jsonResponse = new JSONObject();
    jsonResponse.put("message", "Logout Successful");
    response.getWriter().write(jsonResponse.toString());
  }

}

WebSecurityConfig
--------------------------------------

@Configuration
@EnableWebSecurity
public class WebSecurityConfig extends WebSecurityConfigurerAdapter {


  @Autowired
  private CustomLoginSuccessfulHandler loginSuccessfulHandler;

  @Autowired
  private CustomLoginFailureHandler loginFailureHandler;

  @Autowired
  private CustomLogoutSuccessfulHandler logoutSuccessfulHandler;

  @Autowired
  private CustomAccessDeniedHandler customAccessDeniedHandler;

  @Autowired
  private CustomAuthenticationEntryPoint customAuthenticationEntryPoint;

  @Bean
  @Override
  public AuthenticationManager authenticationManagerBean() throws Exception {
    return super.authenticationManagerBean();
  }

  @Override
  protected void configure(AuthenticationManagerBuilder auth) throws Exception {
  //@formatter:off
    auth.inMemoryAuthentication()
                .withUser("user").password("password").roles("USER")
                .and()
                .withUser("admin").password("password").roles("ADMIN");
  // @formatter:on

  }

  @Override
  protected void configure(HttpSecurity http) throws Exception {

  //@formatter:off
      http
      .csrf().disable()
          .formLogin()
              .loginProcessingUrl("/auth/login")
              .successHandler(loginSuccessfulHandler)
              .failureHandler(loginFailureHandler)
          .and()
              .logout()
              .logoutUrl("/auth/logout")
              .logoutSuccessHandler(logoutSuccessfulHandler)
          .and()
            .authorizeRequests()
            .antMatchers("/auth/login").permitAll()
            .antMatchers("/secure/admin").access("hasRole('ADMIN')")
            .anyRequest().authenticated()
           .and()
             .exceptionHandling().accessDeniedHandler(customAccessDeniedHandler)
             .authenticationEntryPoint(customAuthenticationEntryPoint)
          .and()
            .anonymous()
              .disable();
  // @formatter:on
  }
  
}

================================================================================
================================================================================

	Import @Configurations from library
	***********************************

some library
---------------

	@Configuration // allows to import this class
	@ComponentScan // Scan for beans and other configuration classes
	public class SomeLibrary {

	    // no main needed here
	
	}

app using the library
---------------------

	@SpringBootApplication
	@Import(SomeLibrary.class) // import the library
	public class OtherApplication {

	    // just put your standard main in this class
	
	}


================================================================================

	org.slf4j.MDC versus ThreadLocal<ExecutionContext>
	**************************************************

slf4j and logback/log4j offer MDC (Mapped Diagnostic Context).

so, you could use 

	MDC.put("executionContext", executionContext)

and then 

	%d %-5level [%thread] %logger [%X{executionContext}] %msg%n

and all log entries will get the execution context injected into the log entry.

Seems like a no-brainer.
The docs say "MDC managed contextual information on a per thread basis".


However, here are the reasons not to:

1. Using MDC, makes execution context data available to the logging system, 
   there may be other consumers of the execution context data for which
   MDC is of no help.
   In this case a use of a ExecutionContextHolder with 
   ThreadLocal<ExecutionContext> will provide a more generic solution.

2. I may not want the context data in EVERY log entry.

3. Sounds like there is a concern with using MDC in a pooled thread env:

MDC and Thread Pools: A Bad Combination
http://ashtonkemerling.com/blog/2017/09/01/mdc-and-threadpools/

	On paper you could generate a UUID per request, insert it into the MDC and presto you have a UUID per request in each log line! Since threads are created per request, the MDC will be empty each time.

	Except, that’s not really how Java programming works these days. Threads are expensive, and so for the sake of efficiency modern Java aims to minimize the number of threads created. This means using non-blocking IO (NIO), or reusing threads via Thread Pools where possible, which avoids creating new threads. 

	So, what happens to our MDC when we reuse threads? 
	Well, we end up with the wrong MDC!

For the above reasons, using your own ExecutionContextHolder may be a better idea
for the moment.


================================================================================

  @EnableScheduling and @Scheduled
  ********************************

To schedule a job in spring-boot app to run periodically

@EnableScheduing

  internally imports the SchedulingConfiguration via 
  @Import(SchedulingConfiguration.class)


@SpringBootApplication
@EnableScheduling
public class DemoApplication {


@Scheduled

add on methods which you want to schedule
methods must NOT have arguments.

ScheduledAnnotationBeanPostProcessor scans all declared beans for the presense
of the @Scheduled annotations.

  @Scheduled(
      initialDelay = 1000,
      fixedRate = 10000
  )
  public void scheduledCurrentTime() {
    logger.info("Current time: {}", Calendar.getInstance().getTime());
  }


================================================================================

  Enabling HTTPS
  **************

Configuring key-store and trust-store.

https://docs.spring.io/spring-boot/docs/current/reference/html/common-application-properties.html

server.ssl.ciphers= # Supported SSL ciphers.
server.ssl.client-auth= # Whether client authentication is wanted ("want") or needed ("need"). Requires a trust store.
server.ssl.enabled= # Enable SSL support.
server.ssl.enabled-protocols= # Enabled SSL protocols.
server.ssl.key-alias= # Alias that identifies the key in the key store.
server.ssl.key-password= # Password used to access the key in the key store.
server.ssl.key-store= # Path to the key store that holds the SSL certificate (typically a jks file).
server.ssl.key-store-password= # Password used to access the key store.
server.ssl.key-store-provider= # Provider for the key store.
server.ssl.key-store-type= # Type of the key store.
server.ssl.protocol=TLS # SSL protocol to use.
server.ssl.trust-store= # Trust store that holds SSL certificates.
server.ssl.trust-store-password= # Password used to access the trust store.
server.ssl.trust-store-provider= # Provider for the trust store.
server.ssl.trust-store-type= # Type of the trust store.


https://docs.spring.io/spring-cloud-dataflow/docs/1.0.1.RELEASE/reference/html/getting-started-security.html

By default, the dashboard, management, and health endpoints use HTTP as a transport. You can switch to HTTPS easily, by adding a certificate to your configuration in application.yml.

server:
  port: 8443                                         1
  ssl:
    key-alias: yourKeyAlias                          2
    key-store: path/to/keystore                      3
    key-store-password: yourKeyStorePassword         4
    key-password: yourKeyPassword                    5
    trust-store: path/to/trust-store                 6
    trust-store-password: yourTrustStorePassword     7

1 change the port to a more common HTTPs-typical port.

2 The alias (or name) under which the key is stored in the keystore.

3 The path to the keystore file. Classpath resources may also be specified, by using the classpath prefix: classpath:path/to/keystore

4 The password of the keystore.

5 The password of the key.

6 The path to the truststore file. Classpath resources may also be specified, by using the classpath prefix: classpath:path/to/trust-store

7 The password of the trust store.

================================================================================

  WebMvcConfigurerAdapter is deprecated
  *************************************

This warning will appear if we’re using Spring version 5 (or Spring Boot 2), either when upgrading an existing application or building a new application with the old API.

In earlier versions of Spring, up to and including version 4, if we wanted to configure a web application, we could make use of the WebMvcConfigurerAdapter class:

  @Configuration
  public WebConfig extends WebMvcConfigurerAdapter {
       
      // ...
  }  

Java 8 added the concept of default methods in interfaces. Naturally, the Spring team updated the framework to make full use of the new Java language features.

Now, use

  @Configuration
  public WebConfig implements WebMvcConfigurer {
      // ...
  }

================================================================================

  log REST request/response HTTP Headers 
  **************************************

One option: 
https://www.baeldung.com/spring-http-logging  
-------------------------------------------------------------------------

@Configuration
public class RequestLoggingFilterConfig {
 
    @Bean
    public CommonsRequestLoggingFilter logFilter() {
        CommonsRequestLoggingFilter filter
          = new CommonsRequestLoggingFilter();
        filter.setIncludeQueryString(true);
        filter.setIncludePayload(false);
        filter.setMaxPayloadLength(10000);
        filter.setIncludeHeaders(true);
        filter.setAfterMessagePrefix("REQUEST DATA : ");
        return filter;
    }
}

application.yml:

logging.level:
  org.springframework.web.filter.CommonsRequestLoggingFilter: DEBUG

Output:

2018-09-07 16:40:32.915 DEBUG 18971 --- [nio-9042-exec-2] o.s.w.f.CommonsRequestLoggingFilter      : Before request [uri=/blah;headers={gtid=[abc-123-456-xyz], cache-control=[no-cache], postman-token=[1ea3d58a-badb-48aa-8ff0-3a8f29ab32bd], authorization=[Bearer xyz], user-agent=[PostmanRuntime/7.2.0], accept=[*/*], host=[localhost:9042], accept-encoding=[gzip, deflate], connection=[keep-alive]}]

. . .

2018-09-07 16:40:33.110 DEBUG 18971 --- [nio-9042-exec-2] o.s.w.f.CommonsRequestLoggingFilter      : REQUEST DATA : uri=/blah;headers={gtid=[abc-123-456-xyz], cache-control=[no-cache], postman-token=[1ea3d58a-badb-48aa-8ff0-3a8f29ab32bd], authorization=[Bearer xyz], user-agent=[PostmanRuntime/7.2.0], accept=[*/*], host=[localhost:9042], accept-encoding=[gzip, deflate], connection=[keep-alive]}]

-------------------------------------------------------------------------

Another option:  extend OncePerRequestFilter implement Order

https://gist.github.com/int128/e47217bebdb4c402b2ffa7cc199307ba
http://slackspace.de/articles/log-request-body-with-spring-boot/


@Configuration
public class RequestLoggingFilterConfiguration {

  @Bean
  public HttpRequestLoggingFilter logFilter() {
    return new HttpRequestLoggingFilter();
  }

}


HttpRequestLoggingFilter.java
-----------------------------

import java.io.IOException;
import java.io.UnsupportedEncodingException;
import java.util.Arrays;
import java.util.Collections;
import java.util.List;
import java.util.stream.Stream;
import javax.servlet.FilterChain;
import javax.servlet.ServletException;
import javax.servlet.http.HttpServletRequest;
import javax.servlet.http.HttpServletResponse;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;
import org.springframework.core.Ordered;
import org.springframework.http.HttpStatus;
import org.springframework.http.MediaType;
import org.springframework.web.filter.OncePerRequestFilter;
import org.springframework.web.util.ContentCachingRequestWrapper;
import org.springframework.web.util.ContentCachingResponseWrapper;

/**
 * This filter logs HTTP request headers.
 */
public class HttpRequestLoggingFilter extends OncePerRequestFilter implements Ordered {

  private final static Logger logger = LoggerFactory.getLogger(HttpRequestLoggingFilter.class);

  private static final List<MediaType> VISIBLE_TYPES = Arrays.asList(
      MediaType.valueOf("text/*"),
      MediaType.APPLICATION_FORM_URLENCODED,
      MediaType.APPLICATION_JSON,
      MediaType.APPLICATION_XML,
      MediaType.valueOf("application/*+json"),
      MediaType.valueOf("application/*+xml"),
      MediaType.MULTIPART_FORM_DATA
  );

  // put filter at the end of all other filters to make sure we are processing after all others
  private static int order = Ordered.LOWEST_PRECEDENCE - 8;

  @Override
  public int getOrder() {
    return order;
  }

  private boolean includeHeaders = true;
  private boolean includePayload = false;
  private boolean logResponse = false;

  public void setIncludeHeaders(boolean includeHeaders) {
    this.includeHeaders = includeHeaders;
  }

  public void setIncludePayload(boolean includePayload) {
    this.includePayload = includePayload;
  }

  public void setLogResponse(boolean logResponse) {
    this.logResponse = logResponse;
  }

  @Override
  protected void doFilterInternal(HttpServletRequest request, HttpServletResponse response,
      FilterChain filterChain) throws ServletException, IOException {

    if (isAsyncDispatch(request)) {
      filterChain.doFilter(request, response);
    } else {
      doFilterWrapped(wrapRequest(request), wrapResponse(response), filterChain);
    }

  }

  protected void doFilterWrapped(ContentCachingRequestWrapper request,
      ContentCachingResponseWrapper response, FilterChain filterChain)
      throws ServletException, IOException {
    try {
      beforeRequest(request, response);
      filterChain.doFilter(request, response);
    } finally {
      afterRequest(request, response);
      response.copyBodyToResponse();
    }
  }

  protected void beforeRequest(ContentCachingRequestWrapper request,
      ContentCachingResponseWrapper response) {
    if (logger.isInfoEnabled() && this.includeHeaders) {
      logRequestHeader(request, request.getRemoteAddr() + "|>");
    }
  }

  protected void afterRequest(ContentCachingRequestWrapper request,
      ContentCachingResponseWrapper response) {
    if (logger.isInfoEnabled()) {
      if (this.includePayload) {
        logRequestBody(request, request.getRemoteAddr() + "|>");
      }
      if (this.logResponse) {
        logResponse(response, request.getRemoteAddr() + "|<");
      }
    }
  }

  private void logRequestHeader(ContentCachingRequestWrapper request, String prefix) {
    final String queryString = request.getQueryString();
    if (queryString == null) {
      logger.info("{} {} {}", prefix, request.getMethod(), request.getRequestURI());
    } else {
      logger.info("{} {} {}?{}", prefix, request.getMethod(), request.getRequestURI(), queryString);
    }
    Collections.list(request.getHeaderNames()).forEach(headerName ->
        Collections.list(request.getHeaders(headerName)).forEach(headerValue ->
            logger.info("{} {}: {}", prefix, headerName, headerValue)));
    logger.info("{}", prefix);
  }

  private void logRequestBody(ContentCachingRequestWrapper request, String prefix) {
    final byte[] content = request.getContentAsByteArray();
    if (content.length > 0) {
      logContent(content, request.getContentType(), request.getCharacterEncoding(), prefix);
    }
  }

  private void logResponse(ContentCachingResponseWrapper response, String prefix) {
    final int status = response.getStatus();
    logger.info("{} {} {}", prefix, status, HttpStatus.valueOf(status).getReasonPhrase());
    response.getHeaderNames().forEach(headerName ->
        response.getHeaders(headerName).forEach(headerValue ->
            logger.info("{} {}: {}", prefix, headerName, headerValue)));

    if (this.includePayload) {
      logger.info("{}", prefix);
      final byte[] content = response.getContentAsByteArray();
      if (content.length > 0) {
        logContent(content, response.getContentType(), response.getCharacterEncoding(), prefix);
      }
    }

  }

  private void logContent(byte[] content, String contentType, String contentEncoding,
      String prefix) {
    final MediaType mediaType = MediaType.valueOf(contentType);
    final boolean visible = VISIBLE_TYPES.stream()
        .anyMatch(visibleType -> visibleType.includes(mediaType));
    if (visible) {
      try {
        final String contentString = new String(content, contentEncoding);
        Stream
            .of(contentString.split("\r\n|\r|\n"))
            .forEach(line -> logger.info("{} {}", prefix, line));
      } catch (UnsupportedEncodingException e) {
        logger.info("{} [{} bytes content]", prefix, content.length);
      }
    } else {
      logger.info("{} [{} bytes content]", prefix, content.length);
    }
  }

  private static ContentCachingRequestWrapper wrapRequest(HttpServletRequest request) {
    if (request instanceof ContentCachingRequestWrapper) {
      return (ContentCachingRequestWrapper) request;
    } else {
      return new ContentCachingRequestWrapper(request);
    }
  }

  private static ContentCachingResponseWrapper wrapResponse(HttpServletResponse response) {
    if (response instanceof ContentCachingResponseWrapper) {
      return (ContentCachingResponseWrapper) response;
    } else {
      return new ContentCachingResponseWrapper(response);
    }
  }
}





================================================================================

  spring boot input validation
  ****************************

Hibernate Validator
=======================

Included with spring-boot-starter-web.


    DecimalMax
    DecimalMin
    Digits
    Email
    Future
    FutureOrPresent
    Max
    Min
    Negative
    NegativeOrZero
    NotBlank
    NotEmpty
    NotNull
    Null
    Past
    PastOrPresent
    Pattern
    Positive
    PositiveOrZero

To enable validate on a resource

    public ResponseEntity<Object> createStudent(@Valid @RequestBody Student student) {
    }

  and annotate your REST resource class fields with appropriate validators.


Examples of validation
----------------------

  @JsonProperty
  @NotNull
  @Pattern(regexp = "^[\\d+]$")
  private String digitsOnly;

  @JsonProperty
  @NotNull
  @Pattern(regexp = "^[\\d]{6}$")
  private String sixDigits;

  @JsonProperty
  @NotNull
  @Digits(integer = 6, fraction = 0) <-- Did not work for me, @Pattern instead.
  private String blah;  

  @JsonProperty
  @NotNull
  @Pattern(regexp = "[^\\d{4}-\\d{2}-\\d{2}$]")
  private Date birthDate;  // 2000-12-31




Custom Validators
==================
https://g00glen00b.be/validating-the-input-of-your-rest-api-with-spring/

While there are many built-in validations already, sometimes, there isn’t an annotation that’s doing exactly what you want. But no worries, what isn’t there can be made! For example, let’s say that our users have to be at least 18 years old (no, it’s not what you’re thinking), so let’s create our own, @Adult annotation:

@Documented
@Retention(RUNTIME)
@Target({FIELD, ANNOTATION_TYPE, PARAMETER})
@Constraint(validatedBy = AdultValidator.class)
public @interface Adult {
    String message() default "{adult}";
    Class<?>[] groups() default { };
    Class<? extends Payload>[] payload() default { };
}


Now, to make this annotation work, we also have to write our business logic in a class called AdultValidator, which we pass to the @Constraint annotation as you can see above.


@Component
public class AdultValidator implements ConstraintValidator<Adult, LocalDate> {
    private static final int ADULT_AGE = 18;

    @Override
    public boolean isValid(LocalDate dateOfBirth, ConstraintValidatorContext constraintValidatorContext) {
        return dateOfBirth != null && LocalDate.now().minusYears(ADULT_AGE).isAfter(dateOfBirth);
    }
}



================================================================================
