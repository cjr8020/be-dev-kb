
	@@@@@@@@@@@@@@@@@@@

		SpringBoot

	@@@@@@@@@@@@@@@@@@@

Resources

multiple authentication mechanisms in a single app using java config
https://stackoverflow.com/questions/25794680/multiple-authentication-mechanisms-in-a-single-app-using-java-config

multiple security entry points
http://www.baeldung.com/spring-security-multiple-entry-points
https://github.com/eugenp/tutorials/blob/master/spring-security-mvc-boot/src/main/java/org/baeldung/multipleentrypoints/MultipleEntryPointsSecurityConfig.java

@Order
https://stackoverflow.com/questions/45529743/ordersecurityproperties-access-override-order-vs-managementserverproperties-a

Multiple HttpSecurity
https://docs.spring.io/spring-security/site/docs/current/reference/html/jc.html


================================================================================

	SpringBoot 2.0 M4 Security Changes
	**********************************

https://spring.io/blog/2017/09/15/security-changes-in-spring-boot-2-0-m4

Until Spring Boot 1.x, the default auto-configuration secured all of the application endpoints using basic authentication. If actuator was on the classpath, there was a separate security configuration that applied to the actuator endpoints. The way these two auto-configurations would turn on and off was completely independent. Because of this, users wanting to provide custom security found themselves fighting ordering issues with WebSecurityConfigurerAdapters.

Additionally, for actuator endpoints, the effects of the management.security.enabled flag based on whether Spring Security was on the classpath or not was quite confusing.

There were a number of properties under security.* and management.security.* that were applicable only to the auto-configuration provided by Spring Boot. For example, if security.basic.enabled was set to false, setting security.sessions would have absolutely no effect and this turned out to be quite misleading.

	Improvements in 2.0
	-------------------

Default Configuration




================================================================================

	SpringBoot Security
	*******************

If Spring Security is on the classpath then web applications will be secure by default with ‘basic’ authentication on all HTTP endpoints. 

To add method-level security to a web application you can also add @EnableGlobalMethodSecurity with your desired settings.


	Default SpringBoot Security
	***************************

The default AuthenticationManager has a single user (‘user’ username and random password, printed at INFO level when the application starts up):

	Using default security password: 78fa095d-3f4c-48b1-ad50-e24c31d5cf35


	Order
	*****

Default Security Configuration Order: 100

if you want to apply a resource server filter chain for '/oauth/***', 
you need to specify order as follows:

(1) : [DEFAULT] (= 100)
(2) : 99 or under (e.g: security.oauth2.resource.filter-order=99)


	Override Default SpringBoot Security
	************************************

You can provide a WebSecurityconfigurerAdapter with 

  @Override
  public void configure(AuthenticationManagerBuilder auth) throws Exception {
  	. . .
  }

  @Override
  public void configure(HttpSecurity http) throws Exception {
  	. . .
  }

doesn't matter! - Default SrpingBoot Security will still be in effect.

You need to annotate your WebSecurityConfigurerAdapter with @EnableWebSecurity


	@Order(SecurityProperties.ACCESS_OVERRIDE_ORDER)
	@Configuration
	@EnableWebSecurity
	public class ApplicationEndpointSecurity extends WebSecurityConfigurerAdapter {

	  @Override
	  public void configure(AuthenticationManagerBuilder auth) throws Exception {
	  	. . .
	  }

	  @Override
	  public void configure(HttpSecurity http) throws Exception {
	  	. . .
	  }

	}


and now those overrides will take effect.

	Purpose of @EnableWebSecurity

Apparently to turn off the default and define your own.


From SpringBoot docs:  

https://docs.spring.io/spring-boot/docs/current/reference/htmlsingle/

	To switch off the default web application security configuration completely you can add a bean with @EnableWebSecurity (this does not disable the authentication manager configuration or Actuator’s security). To customize it you normally use external properties and beans of type WebSecurityConfigurerAdapter (e.g. to add form-based login).

	If you add @EnableWebSecurity and also disable Actuator security, you will get the default form-based login for the entire application unless you add a custom WebSecurityConfigurerAdapter.

	If you define a @Configuration with @EnableWebSecurity anywhere in your application it will switch off the default webapp security settings in Spring Boot (but leave the Actuator’s security enabled). To tweak the defaults try setting properties in security.* (see SecurityProperties for details of available settings) and SECURITY section of Common application properties.




NOTE: on ManagementServerProperties
		-----------------------------

If you provide a @Configuration with 

	@Order(ManagementServerProperties.ACCESS_OVERRIDE_ORDER)

it WILL override the Default SpringBoot Security, but for the Management
endpoint ONLY!!!


	/**
	 * Management Endpoint Configuration.
	 */
	@Configuration
	@Order(ManagementServerProperties.ACCESS_OVERRIDE_ORDER)
	public class ManagementEndpointConfiguration extends WebSecurityConfigurerAdapter {

	  private static final Logger log = LoggerFactory.getLogger(ManagementEndpointConfiguration.class);

	  /* management.security.user.name */
	  @Value("${management.security.user.name}")
	  private String name;

	  /* management.security.user.password */
	  @Value("${management.security.user.password}")
	  @NestedConfigurationProperty
	  private String password;

	  @Override
	  protected void configure(AuthenticationManagerBuilder auth) throws Exception {

	    auth
	        .inMemoryAuthentication()
	        .withUser(name)
	        .password(password)
	        .roles("ACTUATOR");
	  }

	  @Override
	  protected void configure(HttpSecurity http) throws Exception {
	    http
	        .authorizeRequests()
	        .anyRequest()
	        .authenticated()
	        .and()
	        .httpBasic();
	  }
	}







================================================================================

	Formatting Java Time with SpringBoot using Jackson
	**************************************************

https://touk.pl/blog/2016/02/12/formatting-java-time-with-spring-boot-using-json/

add 

    <dependency>
      <groupId>com.fasterxml.jackson.datatype</groupId>
      <artifactId>jackson-datatype-jsr310</artifactId>
      <version>2.9.2</version>
    </dependency>

appliation.yml:

	spring.jackson.serialization.write_dates_as_timestamps: false


Custom formatting

	@JsonFormat(pattern = "dd::MM::yyyy")
	private final LocalDate localDate;

	@JsonFormat(pattern = "KK:mm a")
	private final LocalTime localTime;

now you get

{  
   "version":2,
   "localDate":"01::01::2016",
   "localTime":"10:24 AM",
   "localDateTime":"2016-01-01T10:24",
   "zonedDateTime":"2016-01-01T10:24:00+01:00"
}

================================================================================

	Jetty instead of Tomcat
	***********************

		<dependency>
			<groupId>org.springframework.boot</groupId>
			<artifactId>spring-boot-starter-web</artifactId>
			<exclusions>
				<exclusion>
					<groupId>org.springframework.boot</groupId>
					<artifactId>spring-boot-starter-tomcat</artifactId>
				</exclusion>
			</exclusions>
		</dependency>

		<dependency>
			<groupId>org.springframework.boot</groupId>
			<artifactId>spring-boot-starter-jetty</artifactId>
		</dependency>


================================================================================

	Typesafe configuration properties
	*********************************

https://docs.spring.io/spring-boot/docs/1.2.0.RELEASE/reference/htmlsingle/#boot-features-external-config-typesafe-configuration-properties


	Using the @Value("${property}") annotation to inject configuration properties can sometimes be cumbersome, especially if you are working with multiple properties or your data is hierarchical in nature. Spring Boot provides an alternative method of working with properties that allows strongly typed beans to govern and validate the configuration of your application.

	When the @EnableConfigurationProperties annotation is applied to your @Configuration, any beans annotated with @ConfigurationProperties will be automatically configured from the Environment properties. This style of configuration works particularly well with the SpringApplication external YAML configuration.

# application.yml

oauth:
    signingKey: ASDGA$%ADFDASFSDFAG


Option 1:  @Component/@ConfigurationProperties class + @Autowired
Option 2:  @ConfigurationProperties class + @EnableConfigurationProperties(class) + @Autowired


Option 1: @Component/@ConfigurationProperties class + @Autowired
--------------------------------------------------------------------------------

1. Create a @Component annotated with @ConfigurationProperties

	@Component
	@ConfigurationProperties(prefix = "oauth")
	public class OAuthProperties {

	  private String signingKey;

	  public String getSigningKey() {
	    return signingKey;
	  }

	  public void setSigningKey(String signingKey) {
	    this.signingKey = signingKey;
	  }

	}

2. Create a @Configuration and @Autowire

	@Configuration
	public class JwtConfiguration {

	  @Autowired
	  private OAuthProperties oAuthProperties;

	  . . .
	}


Option 2: @ConfigurationProperties class + @EnableConfigurationProperties(class) + @Autowired
--------------------------------------------------------------------------------

1. Create a class with @ConfigurationProperties

	@ConfigurationProperties(prefix = "oauth")
	public class OAuthProperties {

	  private String signingKey;

	  public String getSigningKey() {
	    return signingKey;
	  }

	  public void setSigningKey(String signingKey) {
	    this.signingKey = signingKey;
	  }

	}

2. Create a @Configuration class and @EnableConfigurationProperties(OAuthProperties.class)

	@Configuration
	@EnableConfigurationProperties(OAuthProperties.class)
	public class JwtConfiguration {

	  @Autowired
	  private OAuthProperties oAuthProperties;

	  . . .

	}


================================================================================

	Maven resource filtering
	************************

If you are inheriting from the spring-boot-starter-parent POM, the default filter token of the maven-resources-plugins has been changed from ${*} to @ (i.e. @maven.token@ instead of ${maven.token}) to prevent conflicts with Spring-style placeholders. If you have enabled maven filtering for the application.properties directly, you may want to also change the default filter token to use other delimiters.

{
  "claims-intake-api.version" : "@project.version@",
  "build.timestamp" : "@timestamp@"
}

  <build>
    <resources>
      <!-- resource supporting version info -->
      <resource>
        <directory>src/main/resources</directory>
        <filtering>true</filtering>
        <includes>
          <include>${version.info.file}</include>
        </includes>
      </resource>
      <resource>
        <directory>src/main/resources</directory>
        <filtering>false</filtering>
        <excludes>
          <exclude>${version.info.file}</exclude>
        </excludes>
      </resource>
    <resources>


================================================================================
